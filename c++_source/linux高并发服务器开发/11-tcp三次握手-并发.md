#   1. TCP三次握手

```c
TCP: 面向连接的, 安全的, 流式传输协议
// 这是在客户端和服务器建立连接的时候做的, 这是协议的行为
// 目的: 保证通信的双方互相建立了连接
// 三次握手的第一次是由客户端发起的
```

![](assets/tcp.png)

```shell
# SYN: 请求建立连接
# ACK: 同意
# FIN: 断开连接的请求

seq/Seq: 32位的序号-> 随机生成的
ack/Ack: 32位确认序号 -> 确认上一次的数据已经接收了多少
```

![](assets/3.png)

```c
/*
	第一次握手:
		1. 客户端将SYN标志位赋值为1
		2. 生成一个随机的32位序号
		3. 这个序号后边是可以携带数据的 (数据大小)
	第二次握手:
		1. 服务器接收客户端的连接: ACK=1
		2. 服务器会回发一个确认序号: ack=随机序号+数据长度+SYN标志位(按一个字节算)
		3. 服务器会向客户端发起连接请求: SYN=1
		4. 服务器会生成一个随机序号: seq=k
	第三次握手:
		1. 客户端答应服务器的连接请求: ACK=1
		2. 客户端回复收到了服务器的数据: ack=服务器的随机序号+数据长度+SYN(按一个字节算)
*/
	
```



# 2. TCP滑动窗口

> 滑动窗口是 TCP 中用于实现诸如 ACK 确认、流量控制、拥塞控制的承载结构。
>
> 窗口理解为一块缓存就可以了.
>
> 滑动窗口的内存是在变化的 -> 存储的数据量在变化
>
> - 通信的双方都有滑动窗口
>   - 服务器
>     - 发送数据的窗口
>     - 接收数据的窗口
>   - 客户端
>     - 发送数据的窗口
>     - 接收数据的窗口

这个图是一个单向的数据发送:

![](assets/sliding_window.png)

```shell
# 白色格子: 空闲的空间
# 灰色格子: 数据已经被发送出去, 但是还没有被接收
# 发送端紫色: 还没有发送出去的
# 接收端紫色: 已经接收到的数据
```

![](assets/滑动窗口.jpg)

```shell
# mss: 最大的数据段大小 Maximum Segment Size -> 一条数据的最大数据量
# win: 滑动窗口
1. 客户端向服务器发起连接, 客户端的滑动窗口大小为4096, 一次发送的最大数据量1460
2. 服务器接收连接请求(第二次握手), 告诉客户端服务器的滑动窗口大小为6144, 一次发送的最大数据量1024
3. 第三次握手
4. 4-9 客户端连续给服务器发送了 6k数据, 每次发送1k
5. 第10次, 服务器告诉客户端: 发送的6k数据已经收到存储到滑动窗口缓存中, 缓存数据已经处理了2k
6. 第11次, 服务器告诉客户端: 发送的6k数据已经收到存储到滑动窗口缓存中, 缓存数据已经处理了4k
7. 第12次, 客户端给服务器发送1k数据
8. 第13次, 主动请求和服务器断开连接, 并且给服务器发送了1k数据
9. 第14次, 服务器回复ACK8194, a: 同意断开连接的请求 b: 告诉客户端我已经收到刚才2k数据 c: 滑动窗口2k
10. 第15, 16次, 通知客户端滑动窗口中的数据处理完了
11. 第17次, 服务器给客户端发送FIN, 断开和客户端的连接
12. 第18次, 客户端同意了服务器的断开请求
```

# 3. TCP四次挥手

```c
/*
	发生在断开连接的时候 -> close();
	客户端和服务器端谁都可以发起挥手的动作, 谁先调用close()函数就是谁发起的
	
	因为tcp在连接的时候, 建立的是双向连接, 因此在断开的时候需要双向断开
*/
```



![](assets/4.png)

# 4. TCP通信并发

​		![1558162823677](assets/1558162823677.png)

- 多进程 -> 服务器

  ```c
  /*
  	处理思路:
  		1. 父进程, 若干个子进程
  		2. 父进程: 等待并接受连接请求
  		3. 子进程: 通信, 接受一个连接请求, 创建一个子进程
  */
  父子进始终共享 -> 文件描述符
  用户区的数据: 读共享, 写复制
  ```

  ```c
  
  // 信号捕捉的回调函数
  void recycleChild(int num)
  {
      while(1)
      {
          int ret = waitpid(-1, NULL, wnohang);
          if(ret == -1)
          {
              printf("child process 都死了");
              break;
          }
          else if(ret == 0)
          {
              printf("child process 都还活着...");
              break;
          }
      }
  }
  
  // 伪代码
  int main()
  {
      // 创建套接字
      int lfd = socket();
      // 绑定
      bind(lfd, ip, port);
      // 监听
      listen(lfd, block);
      
      // 设置信号捕捉
      sigaction();
      
      while(1)
      {
          // 等待并接受连接请求
          int cfd = accept(lfd, addr, len);
          // 创建子进程
          pid_t pid = fork();
          if(pid == 0)
          {
              // 子进程
              // 通信 -> 循环
              while(1)
              {
                  // 接收数据
                  int ret = read(cfd, buf, sizeof(buf));
                  if(ret == 0)
                  {
                      // 客户端断开连接
                      break;
                  }
                  else if(ret == -1)
                  {
                      break;
                  }
                  else
                  {
                      // 没有任何异常, 回复客户端
                      write();
                  }
                  // 杀死这个子进程
                  exit(0);
              }
          }
      }
      return 0;
  }
  ```

- 多线程 -> 服务器

  ```c
  /*
  	1. 父线程 -> 1个, 子线程-> 多个
  	2. 父线程 -> accept() -> while(1)
  	3. 子线程: 接受了客户端的连接请求, 需要通信, 创建子线程完成后续操作
  	
  	父子线程, 兄弟线程直间共享什么? -> 使用的是同一个虚拟地址空间
  		- 堆, 全局数据区
  	不共享什么? -> 栈区数据
  */
  
  // 子线程处理函数
  void* working(void* arg)
  {
  	while(1)
      {
          // 和建立连接的客户端通信
          int ret = read(fd, buf, sizeof(buf));
          if(ret == 0)
          {
              break;
          }
          else if(ret == -1)
          {
              
          }
          else
          {
              write(fd, data, strlen(data)+1);
          }
      }
      return NULL;
  }
  
  int main()
  {
      // 1. 创建监听的套接字
      int lfd = socket();
      // 2. 绑定
      bind(lfd, addr, len);
      // 3. 监听
      listen(lfd, block);
      
      while(1)
      {
           // 4. 等待并接受连接请求
          int cfd = accept(lfd, addr, len);
          // 5. 创建子线程
          pthread_create(&tid, NULL, working, arg);
          pthread_detach(&tid);
      }
     
      return 0;
  }
  ```

  

# tcp通信细节

```c
// 通过socket函数得到文件描述符 -> 内核缓冲区
套接字通信默认也是阻塞的 -> 是这些函数操作的文件描述符导致了函数的阻塞
	服务器端:
		- accept
		- read
		- write
	客户端:
		- read
		- write

// 通信过程中, 如果确定对方已经断开连接了?
- 如果连接是一个保持状态, 缓冲区中没有数据, read阻塞的
- read解除阻塞, 返回值为0 -> 对方已经关闭了连接
- read返回值 -1 -> 函数调用失败
```

