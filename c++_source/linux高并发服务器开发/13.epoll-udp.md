# 1. select和poll

## 1.1 select

![](assets/select.png)

- 函数

  ```c
  // 相关函数
  #include <sys/time.h>
  #include <sys/types.h>
  #include <unistd.h>
  // sizeof(fd_set) = 128
  int select(int nfds, fd_set *readfds, fd_set *writefds,
                    fd_set *exceptfds, struct timeval *timeout);
  	参数:
  		- nfds: 委托内核检测的最大文件描述符的值 + 1
          - readfds: 读集合, 委托内核检测哪些文件描述符的读属性
          	- 一般检测读操作
          	- 对的是对方发送过来的数据, 因为读是被动的接收数据
          		- 因此需要时时检测对应读缓冲区
          	- 这是一个传入传出的参数
          - fd_set: 写集合, 委托内核检测哪些文件描述符的写属性
          	- 这是一个传入传出的参数
          	- 委托内核检测写缓冲区是不是还可以写数据(不满就可以写)
          - exceptfds: 异常集合, 委托内核检测哪些文件描述符出现了异常
         	- timeout:
  			struct timeval {
                 long    tv_sec;         /* seconds */
                 long    tv_usec;        /* microseconds */
             };
  			- NULL: 永久阻塞, 直到检测到了文件描述符有变化
  			- tv_sec = 0, tv_usec = 0, 不阻塞
  			- tv_sec > 0 || tv_usec > 0, 阻塞对应的时间长度
  	返回值:
  		-1: 失败
  		>0(n): 检测的集合中有n个文件描述符发送的变化 
  
  // 将参数文件描述符fd对应的标志位, 设置为0
  void FD_CLR(int fd, fd_set *set);
  // 判断fd对应的标志位到底是0还是1, 返回值: fd对应的标志位的值, 0, 返回0, 1->返回1
  int  FD_ISSET(int fd, fd_set *set);
  // 将参数文件描述符fd对应的标志位, 设置为1
  void FD_SET(int fd, fd_set *set);
  // fd_set 共有1024bit, 全部初始化为0
  void FD_ZERO(fd_set *set);
  ```

## 1.2 poll

> select的简单的改进版
>
> - 内核对select集合是进行线性遍历
>
>   - 最大支持检测 1024个, 可以修改内核源码, 重新编译
>   - 以数组的方式来维护的
>
> - ....poll集合.....线性
>
>   - 以链表的方式维护
>   - 可以大于1024
>
>   

- 函数

  ```c
  #include <poll.h>
  struct pollfd {
  	int   fd;         /* 委托内核检测的文件描述符 */
  	short events;     /* 委托内核检测文件描述符的什么事件 */
  	short revents;    /* 文件描述符实际发生的事件 */
  };
  struct pollfd myfd;
  myfd.fd = 5;
  myfd.events = POLLIN | POLLOUT;
  
  struct pollfd myfd[100];
  int poll(struct pollfd *fds, nfds_t nfds, int timeout);
  	参数:
  		- fds: 这是一个struct pollfd数组, 这是一个要检测的文件描述符的集合
  		- nfds: 原始中最后一个有效元素下标 + 1
          - timeout: 阻塞时长
          	0: 不阻塞
          	-1: 阻塞, 检测的fd有变化解除阻塞
          	>0: 阻塞时长, 单位: 毫秒
        返回值:
  		-1: 失败
  		>0(n): 检测的集合中有n个文件描述符发送的变化 
  ```

# 2. epoll

> 内核检测epoll传递的fd集合, 是以红黑树的形式遍历的
>
> 内核创建一块共享内存: 内核和用户区共享
>
> 如果内存1G, epoll就支持10万并发

## 2.1 epoll的使用

- 函数

  ```c
  #include <sys/epoll.h>
  // 创建一棵红黑树
  int epoll_create(int size);
  	参数: 
  		size: 没意义, 随便写个数就行
  	返回值;
  		>0: 文件描述符, 操作epoll树的根节点
  
  typedef union epoll_data {
  	void        *ptr;	// 复杂
  	int          fd;	// 简单
  	uint32_t     u32;
  	uint64_t     u64;
  } epoll_data_t;
  
  struct epoll_event {
  	uint32_t     events;      /* Epoll events */
  	epoll_data_t data;        /* User data variable */
  };
  Epoll检测的事件:
  	- EPOLLIN
  	- EPOLOUT
  	- EPOLLERR
  
  // 对epoll树进行管理: 添加节点, 删除节点, 修改已有的节点属性
  int epoll_ctl(int epfd, int op, int fd, struct epoll_event *event);
  	参数:
  		- epfd: epoll_create的返回值, 通过这个值就可以找到红黑树
  		- op: 要进行什么样的操作
  			EPOLL_CTL_ADD: 注册新节点, 添加到红黑树上
  			EPOLL_CTL_MOD: 修改检测的文件描述符的属性
  			EPOLL_CTL_DEL: 从红黑树上删除节点
  		- fd: 要检测的文件描述符的值
  		- event: 检测文件描述符的什么事件
  
  // 检测函数
  struct epoll_event events[1000];
  int epoll_wait(int epfd, struct epoll_event *events, int maxevents, int timeout);
  	参数:
  		- epfd: epoll_create的返回值, 通过这个值就可以找到红黑树
  		- events: 传出参数, 保存了发生变化的文件描述符的信息
  		- maxevents: 第二个参数结构体数组的大小
  		- timeout: 阻塞时间
  			- 0: 不阻塞
  			- -1: 一直阻塞, 知道检测的fd有状态变化, 解除阻塞
  			- >0: 阻塞的时长(毫秒)
       返回值:
  		- 成功: 有多少个文件描述符状态发生了变化 > 0
          - 失败: -1
  ```

  ![1558411208316](assets/1558411208316.png)



## 2.2 epoll 的工作模式

- LT模式 -> 默认的

  假设委托内核检测读事件 -> 检测fd的读缓冲区

  - 读缓冲区有数据 -> epoll检测到了会给用户通知
    - 用户就是不读, 数据一直在缓冲区中, epoll会一直通知
    - 用户读了一部分, epoll会通知用户
    - 缓冲区数据被读完了, 就不在通知了

  > `LT(level triggered)是缺省的工作方式，并且同时支持block和no-block socket`。在这种做法中，内核告诉你一个文件描述符是否就绪了，然后你可以对这个就绪的fd进行IO操作。`如果你不作任何操作，内核还是会继续通知你的`。

- ET模式

  假设委托内核检测读事件 -> 检测fd的读缓冲区
  
  - 读缓冲区有数据 -> epoll检测到了会给用户通知
    - 用户就是不读, 数据一直在缓冲区中, epoll下次检测的时候就不通知了
  
  > `ET(edge-triggered)是高速工作方式，只支持no-block socket`。在这种模式下，当描述符从未就绪变为就绪时，内核通过epoll告诉你。然后它会假设你知道文件描述符已经就绪，并且不会再为那个文件描述符发送更多的就绪通知，直到你做了某些操作导致那个文件描述符不再为就绪状态了。`但是请注意，如果一直不对这个fd作IO操作(从而导致它再次变成未就绪)，内核不会发送更多的通知(only once)`。
  >
  > `ET模式在很大程度上减少了epoll事件被重复触发的次数，因此效率要比LT模式高`。epoll工作在ET模式的时候，`必须使用非阻塞套接口`，以避免由于一个文件句柄的阻塞读/阻塞写操作把处理多个文件描述符的任务饿死。
  
  ```c
  // 设置为边沿触发模式, 修改事件的属性
  struct epoll_event {
  	uint32_t     events;      /* Epoll events */
  	epoll_data_t data;        /* User data variable */
  };
  Epoll检测的事件:
  	- EPOLLIN
  	- EPOLOUT
  	- EPOLLERR
  	- EPOLLET   -> 设置边沿触发模式
  	
  // 设置通信文件描述符为非阻塞
  // 获取文件描述flag属性
  int flag = fcntl(fd, F_GETFL);
  // 添加非阻塞属性
  flag = flag | O_NONBLOCK;
  // 将新的flag属性设置给fd
  fcntl(fd, F_SETFL, flag);
  ```
  
  

# 3. udp

- 通信流程

  ![](assets/udp.jpg)

  - 服务器端
    - 创建通信的套接字
      - int fd = socket( af_inet, SOCK_DGRAM, 0)
    - 绑定 -> 通信的fd 和本地 IP / port 绑定
      - struct sockaddr_in addr;
    - 通信
      - 接收数据: recvfrom
      - 发送数据: sendto
    - 关闭通信的fd
      - close(fd);
  - 客户端
    - 创建一个通信的套接字
    - 通信
      - 接收数据: recvfrom
      - 发送数据: sendto
    - 关闭通信的文件描述符
      - close();

- 操作函数

  ```c
  #include <sys/types.h>
  #include <sys/socket.h>
  // tcp 发送数据的函数 write
  ssize_t send(int sockfd, const void *buf, size_t len, int flags);
  // udp 发送数据
  ssize_t sendto(int sockfd, const void *buf, size_t len, int flags,
                        const struct sockaddr *dest_addr, socklen_t addrlen);
  	参数:
  		- sockfd: 通信的fd
		- buf: 要发送的数据
  		- len: 要发送的数据的长度
  		- flags: 0
          - dest_addr: 通信的另外一端的地址信息
          - addrlen: dest_addr的内存大小
  // tcp 接收数据 read
  ssize_t recv(int sockfd, void *buf, size_t len, int flags);
  // udp 接收数据函数
  ssize_t recvfrom(int sockfd, void *buf, size_t len, int flags,
                          struct sockaddr *src_addr, socklen_t *addrlen);
  	参数:
  		- sockfd: 通信的fd
  		- buf: 接收数据的一块内存
  		- len: 接收数据的内存(第二个参数)大小
  		- flags: 0
          - src_addr: 接收谁的数据, 就写入了那个终端的地址信息, 如果不要这部分数据 -> NULL
          - addrlen: src_addr参数对应内存大小(传入传出参数)
              
   int accept(int sockfd, struct sockaddr *addr, socklen_t *addrlen);
  ```
  
  

```c
// 回调
int myfunc(int a, char* pt)
{
}
int funcA(int a, int b, int(*func)(int , char*))
{
	if()
	{
	}
	else
	{
		char* p = xxxx;
		func(a, p);
	}
}
int main()
{
	funcA(10, 20, myfunc);
}
```

