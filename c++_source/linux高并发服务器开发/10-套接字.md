# 1. 概念

- 网络设计模式

  - B/S

    - 客户端： 浏览器
    - 服务器： 服务器

    优势： 跨平台， 开发成本低

    劣势： 

    ​	是的协议的固定的： http， https

    ​	不能处理大的数据

  - C/S

    - 客户端： 桌面应用程序
    - 服务器： 后台服务器

     优势： 可以处理大量的磁盘数据

     劣势： 如果跨平台， 需要重新开发， 成本高

- IP和端口

  - IP地址
    - IPV4
      - 实际是一个32位的整形数 -> 本质 -> 4字节   int a;
      - 我们看的的不是这个整形数, 点分十进制字符串 -> 192.168.247.135 
        - 分成了4份, 每份1字节, 8bit   ->  char , 最大值为 255  -> 最大取值: 255.255.255.255
      - IP可以有多少个  2^32^ - 1 个
    - IPV6
      - 实际是一个128位的整形数
      - xxx:xxx:xxx:xxx:xxx:xxx:xxx:xxx ,  分成了8分, 每份16位 -> 每一部分以16进制的方式表示
      - IP可以有多少个  2^128^ - 1 个
    - IP地址的作用:
      - 通过IP地址能够找到某一台主机
  - 端口
    - 在一个主机上运行着很多进程
    - 如果将数据发送到某台主机上的某个进程?
    - 如果要进程网络通信, 可以让这个进程绑定一个端口
      - 通过这个端口就可以确定某个进程
    - 端口号: unsigned short int   ->   16位
      - 端口取值范围: 0 -65535    (2^16^)

- OSI/ISO 网络分层模型

  > OSI（Open System Interconnect），即开放式系统互联。 一般都叫OSI参考模型，是ISO（国际标准化组织组织）在1985年研究的网络互联模型。

  - 七层模型

    ```c
    底层 --------->上层
    物 数 网 传 会 表 应
    ```

    > - 物理层：
    >   - 物理层负责最后将信息编码成电流脉冲或其它信号用于网上传输
    > - 数据链路层:  
    >   - 数据链路层通过物理网络链路供数据传输。
    >   - 规定了0和1的分包形式，确定了网络数据包的形式；
    > - 网络层
    >   - 网络层负责在源和终点之间建立连接;
    >   - 此处需要确定计算机的位置，怎么确定？IPv4，IPv6
    > - 传输层
    >   - 传输层向高层提供可靠的端到端的网络数据流服务。
    >   - 每一个应用程序都会在网卡注册一个端口号，该层就是端口与端口的通信
    > - 会话层
    >   - 会话层建立、管理和终止表示层与实体之间的通信会话；
    >   - 建立一个连接（自动的手机信息、自动的网络寻址）;
    > - 表示层:
    >   - 对应用层数据编码和转化, 确保以一个系统应用层发送的信息 可以被另一个系统应用层识别;
    >   - 可以理解为：解决不同系统之间的通信，eg：手机上的QQ和Windows上的QQ可以通信；
    > - 应用层:
    >   - 规定数据的传输协议

  - 四层模型

    ```shell
    底层 --------->上层
    物 数 网 传 会 表 应
    
    会 表 应      应用层
           传  ->传输层       
                     网络层
           物 数 -> 网络接口层
    ```

    ![](assets/ip四层协议模型.png)

    

- 协议的概念

  - TCP协议

    ![](assets/tcp.png)

  - UDP协议

    ![](assets/udp.png)

  - IP协议

    ![](assets/ip.png)

  - 以太网帧协议

    ![](assets/mac.png)

  - 数据的封装

  ![1558001080021](assets/1558001080021.png)

# 2. 协议格式

# 3. socket编程

> Socket套接字由远景研究规划局（Advanced Research Projects Agency, ARPA）资助加里福尼亚大学伯克利分校的一个研究组研发。其目的是将TCP/IP协议相关软件移植到UNIX类系统中。设计者开发了一个接口，以便应用程序能简单地调用该接口通信。这个接口不断完善，最终形成了Socket套接字。Linux系统采用了Socket套接字，因此，Socket接口就被广泛使用，到现在已经成为事实上的标准。与套接字相关的函数被包含在头文件sys/socket.h中。

![](assets/插座.png)

```c
// 套接字通信分两部分:
 - 服务器端: 被动接受连接的角色, 不会主动发起连接
 - 客户端通信: 主动向服务器发起连接
 
 socket是一套通信接口, 下linux和windows都可以使用, 但是又细微差别
```

## 3.1 字节序

> 在各种计算机体系结构中，对于字节、字等的存储机制有所不同，因而引发了计算机通信领域中一个很重要的问题，即通信双方交流的信息单元（比特、字节、字、双字等等）应该以什么样的顺序进行传送。如果不达成一致的规则，通信双方将无法进行正确的编/译码从而导致通信失败。
>
> <font color="red">**字节序，顾名思义字节的顺序，就是大于一个字节类型的数据在内存中的存放顺序(一个字节的数据当然就无需谈顺序的问题了)**。</font>
>
> 目前在各种体系的计算机中通常采用的字节存储机制主要有两种：Big-Endian 和 Little-Endian，下面先从字节序说起。

​                                  	![](assets/bits-order.jpg)

> 《格列佛游记》中记载了两个征战的强国，你不会想到的是，他们打仗竟然和剥鸡蛋的姿势有关。
>
> 很多人认为，剥鸡蛋时应该打破鸡蛋较大的一端，这群人被称作“大端（Big endian）派”。可是当今皇帝的祖父小时候吃鸡蛋的时候碰巧将一个手指弄破了。所以，他的父亲（当时的皇帝）就下令剥鸡蛋必须打破鸡蛋较小的一端，违令者重罚，由此产生了“小端（Little endian）派”。
>
> 老百姓们对这项命令极其反感，由此引发了6次叛乱，其中一个皇帝送了命，另一个丢了王位。据估计，先后几次有11000人情愿受死也不肯去打破鸡蛋较小的一端！

- 概念

  - Little-Endian -> 主机字节序
    - 有一个数据: 0x12345678, 在内存中进行存储
    - 内存的低地址位存储数据低位字节, 内存高地址位存储数据的高位字节
  - Big-Endian -> 网络字节序
    - 内存的低地址位存储数据高位字节, 内存的高地址位存储数据的低位字节

- 字节序举例

  ```c
  // 使用16进制在内存中表示这两个数，即:
  	- 0x12 34 56 78   -> 四字节   char -> 255 -> ff  
      - 0x11223344   -> 四字节
  ```

  - 小端

    ```c
    低地址位 -------------> 高地址位
    0x78 	0x56	0x34	0x12
    0x44	0x33	0x22	0x11
    ```

    ![](assets/little.png)

  - 大端

    ```c
    低地址位 -------------> 高地址位
    0x12	0x34	0x56	0x78
    0x11	0x22	0x33	0x44
    ```

    ![](assets/big.png)

- 函数

  > BSD Socket提供了封装好的转换接口，方便程序员使用。包括从主机字节序到网络字节序的转换函数：htons、htonl；从网络字节序到主机字节序的转换函数：ntohs、ntohl。

  ```c
  #include <arpa/inet.h>
  // shot int -> 2字节
  // h -> host
  // n -> network
  // s -> short
  // l -> long
  // xtoxs() -> 进行端口转换
  uint16_t htons(uint16_t hostshort);
  	参数: 主机字节数的short型数值 -> 要转换的数(主机)
  	返回值: 转换之后得到是数据 (网络字节序)
  uint16_t ntohs(uint16_t netshort);
  // long -> 4字节
  // xtoxl() -> 进行IP转换
  uint32_t htonl(uint32_t hostlong);
  uint32_t ntohl(uint32_t netlong);
  ```

## 3.2 IP地址转换

```c
#include <arpa/inet.h>
// 字符串: 192.168.1.100 (点分十进制字符串)
// p -> 点分十进制字符串 IP
// n -> network
// 将主机字节序的 字符串IP -> 网络字节序的 整形数
int inet_pton(int af, const char *src, void *dst);
	参数: 
		- af: 地址族协议, ipv4, ipv6
			ipv4: AF_INET, ipv6:AF_INET6
		- src: 点分十进制字符串 IP
		- dst: 传出参数, 执行一块内存的地址, 将转换得到的 网络字节序的 整形数 存储到这块内存中
	返回值:
		-1: 失败
		1: 成功
		0: 查字典
// 网络字节序的整形IP -> 点分十进制字符串 IP
const char *inet_ntop(int af, const void *src, char *dst, socklen_t size);
	参数:
		- af: 地址族协议, ipv4, ipv6
			ipv4: AF_INET, ipv6:AF_INET6
		- src: 指向要转换的 网络字节序的整形IP 地址
		- dst: 转换成功之后的 点分十进制字符串 存储的位置
		- size: 修饰的就是第三个参数 dst 对应的内存大小
	返回值: 
		NULL: 失败
		非空指针, 指向第三个三种指针的内存: 成功
```

## 3.3 sockaddr数据结构

![](assets/sockaddr.png)

```c
// 这个结构体存储端口和IP地址的
// 客户端 -> 服务器(IP, Port)
```



```c
struct sockaddr {
	sa_family_t sa_family;	// 地址族协议, ipv4, ipv6
	char        sa_data[14];
}

typedef unsigned short  uint16_t;
typedef unsigned int    uint32_t;
typedef uint16_t in_port_t;
typedef uint32_t in_addr_t;
typedef unsigned short int sa_family_t;
#define __SOCKADDR_COMMON_SIZE (sizeof (unsigned short int))

struct in_addr
{
    in_addr_t s_addr;
};  
struct sockaddr_in
{
    sa_family_t sin_family;		/* __SOCKADDR_COMMON(sin_) */
    in_port_t sin_port;         /* Port number.  */
    struct in_addr sin_addr;    /* Internet address.  */
    /* Pad to size of `struct sockaddr'. */
    unsigned char sin_zero[sizeof (struct sockaddr) - __SOCKADDR_COMMON_SIZE -
               sizeof (in_port_t) - sizeof (struct in_addr)];
};  
```

## 3.4 套接字函数

```c
#include <sys/types.h>          /* See NOTES */
#include <sys/socket.h>
#include <arpa/inet.h>	// 包含这个头文件, 上边的两个就可以不写了
// 创建一个套接字
int socket(int domain, int type, int protocol);
	参数: 
		- domain: 地址族协议
			AF_INET: ipv4
			AF_INET6: ipv6
			AF_UNIX, AF_LOCAL: 进行本地套接字通信(进程间通信)
        - type: 通信过程中使用的协议
        	SOCK_STREAM: 流式协议
        	SOCK_DGRAM: 报式协议
        - protocol: 一般写0
        	- SOCK_STREAM: 流式协议默认使用使用: tcp
        	- SOCK_DGRAM: 报式协议默认使用使用: udp
    返回值: 这个文件描述符操作的是内核缓冲区
		成功: 文件描述符 > 0
        失败: -1
// 绑定函数 -> 将fd 和本地的 IP + Port进程绑定
int bind(int sockfd, const struct sockaddr *addr, socklen_t addrlen);
	参数:
		- sockfd: 通过socket函数得到的
		- addr: 需要将IP和Port初始化到这个结构体中
		- addrlen: 第二个参数结构体占的内存大小
// 设置监听
int listen(int sockfd, int backlog);	// /proc/sys/net/core/somaxconn
	参数:
		- sockfd: 通过socket函数得到的
		- backlog: 已经连接成功, 但是还没有被处理的连接
			指定的数值不能大于 /proc/sys/net/core/somaxconn 中存储的数据, 默认为128
// 默认是一个阻塞函数, 阻塞等待客户端请求
// 请求到达, 接收客户端连接
// 得到一个用于通信的文件描述符
int accept(int sockfd, struct sockaddr *addr, socklen_t *addrlen);
	参数:
		- sockfd: 用于监听的文件描述符(套接字)
        - addr: 传出参数, 记录了连接成功的客户端的IP和端口信息
        - addrlen: 第二个参数结构体对应的内存大小
    返回值:
		- 成功: 通信的文件描述符 > 0
        - 失败: -1
            
// 客户端使用该函数连接服务器
int connect(int sockfd, const struct sockaddr *addr, socklen_t addrlen);
	参数:
		- sockfd: 用于通信的文件描述符
		- addr: 客户端要连接的服务器的地址信息
		- addrlen: 第二个参数结构体占的内存大小
	返回值:
		连接成功: 0
        连接失败: -1
            
 // 写数据
 ssize_t write(int fd, const void *buf, size_t count);
 // 读数据
ssize_t read(int fd, void *buf, size_t count);
```

![1558084711685](assets/1558084711685.png)

# 4. TCP通信流程

![](assets/tcp.jpg)

```c
// tcp / udp-> 传输层协议
tcp: 面向连接的, 安全的, 流式传输协议
	- 安全: 不会丢数据
udp: 面向无连接的, 不安全, 报式传输协议

// tcp通信操作流程
// 服务器端操作流程 -> 被动接受连接的角色
1. 创建一个用于监听的套接字
	- 监听: 监听有客户的连接
	- 套接字: 这个套接字是一个文件描述符
2. 将这个监听文件描述符和本地的IP和端口绑定  (IP和端口 == 服务器地址信息)
	- 客户端连接服务器的时候使用的就是这个IP和端口
3. 设置监听, 监听的fd开始工作
4. 阻塞等待, 当有客户端发起连接, 解除阻塞, 接受客户端的连接, 会得到一个用户通信的套接字(fd)
5. 通信
	- 接收数据
	- 发送数据
6. 通信结束, 断开连接
```

```c
// tcp 客户端的通信流程
1. 创建一个用于通信的套接字 (fd)
2. 连接服务器, 需要指定连接的服务器的 IP 和 Port
3. 连接成功, 客户端可以直接和服务通信
	- 接收数据
	- 发送数据
4. 断开连接
```

