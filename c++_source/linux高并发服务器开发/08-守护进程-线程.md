# SIGCHLD信号

##  SIGCHLD的产生条件

```shell
1. 子进程死了, 自杀, 他杀
2. 子进程被暂停了
3. 子进程由暂停状态重新恢复运行
以上三种情况子进程都会给父进程发送信号: SIGCHLD, 父进程默认会忽略这个信号
# 在父进程中拦截该信号 -> 写处理函数( 回收子进程资源 )
```

## 使用SIGCHLD回收子进程

```c
// 回调函数
void recycle(int num)
{
    printf("catch num: %d\n", num);
    // 回收子进程资源
    while(1)
    {
        int ret = waitpid(-1, NULL, WNOHANG);
        if(ret > 0)
        {
            printf("child die, pid = %d\n", ret);
        }
        else if(ret == 0)
        {
            // 死了的子进程回收完成
            break;
        }
        else if(ret == -1)
        {
            printf("所有的子进程死光了, 回收完成!\n");
            break;
        }
    }
}

int main()
{
    // 设置信号阻塞
    sigset_t myset;
    sigemptyset(&myset);
    sigaddset(&myset, SIGCHLD);
    // 如果创建子进程, 这个阻塞会被复制到子进程的地址空间中
    sigprocmask(SIG_BLOCK, &myset, NULL);
    // 如果创建子进程, 这个信号捕捉动作会被子进程继承
    /*
    struct sigaction act;
    act.sa_flags = 0;
    act.sa_handler = recycle;
    sigemptyset(&act.sa_mask);
    sigaction(SIGCHLD, &act, NULL); 
    */
    // 创建子进程 - 20
    pid_t pid;
    for(int i=0; i<1; ++i)
    {
        pid = fork();
        if(pid == 0)
        {
            break;
        }
    }

    if(pid == 0)
    {
        // 子进程
        //printf("child process pid: %d\n", getpid());
    }
    else if(pid > 0)
    {
        // 注册新号捕捉
        struct sigaction act;
        act.sa_flags = 0;
        act.sa_handler = recycle;
        sigemptyset(&act.sa_mask);
        sigaction(SIGCHLD, &act, NULL); 
        sigprocmask(SIG_UNBLOCK, &myset, NULL);
        while(1)
        {
            // 父进程
            printf("parent process pid: %d\n", getpid());
            sleep(3);
        }
    }

    return 0;
}
```

```shell
# 上述程序中: 使用阻塞信号集, 使用了信号捕捉
- 在子进程中会继承父进程中设置的 阻塞信号集
- 子进程会继承父进程中设置的信号的处理动作
	- 回调函数
```



# 1. 守护进程

> 守护进程（Daemon Process），也就是通常说的 Daemon 进程（精灵进程），是 Linux 中的后台服务进程。它是一个生存期较长的进程，通常独立于控制终端并且周期性地执行某种任务或等待处理某些发生的事件。一般采用以d结尾的名字。

## 1.1 守护进程的特点

- 名字一般以d结尾
- 守护进程是脱离终端的
  - 没有输入, 没有输出
- 周期性的执行某些特定的操作

## 1.2 进程组

> 多个进程的一个集合。
>
> ​	- 最少一个
>
> 在linux所有的进程都属于某一个进程组。
>
> 默认父子进程在同一个进程组中。

- 进程组长的指定?

  - 当前进程组中的第一个进程， 就是组长

- 进程组ID如何指定?

  - 和组长的进程ID相同

- 函数

  ```c
  // 获取当前进程所在的进程组的组ID
  pid_t getpgrp(void);
  // 获取指定进程所在的进程组的组ID
  pid_t getpgid(pid_t pid);
  	- pid: 指定的进程的PID
  // 将一个进程送到另外的一个进程组
  // 创建一个新的进程组
  int setpgid(pid_t pid, pid_t pgid);
  	- pid: 要操作的进程的PID
  	- pgid: 进程组ID
  ```

## 1.3 会话

> 多个进程组的集合.

- 函数

  ```c
  // 获取进程所属的会话ID
  #include <unistd.h>
  pid_t getsid(pid_t pid);
  	返回值:
  		成功: 会话ID, 失败: -1
              
  // 创建一个会话
  // 在哪个进程中调用该函数, 这个进程就会被提升为会话
  //  - 没有任何职务的进程才满足条件, 普通的进程
  //  - 这个普通的进程会脱离原来的操作终端
  pid_t setsid(void);
  ```

  

- 创建会话注意事项:

  > - 不能是进程组长
  > - 创建会话的进程成为新进程组的组长
  > - 有些linux版本需要root权限执行此操作(ubuntu不需要)
  >
  > - 创建出的新会话会丢弃原有的控制终端
  >
  > - 一般步骤:先fork, 父亲死,  儿子执行创建会话操作(setsid)

## 1.4 创建守护进程的步骤

```c
- 1. 父进程创建子进程, 杀死父进程   -> 必须
- 2. 将子进程提升为会话			-> 必须
		setsid();
- 3. 修改进程的工作目录, 工作目录切换到不能被卸载的目录中: / /home	-> 不是
		目的: 防止有些不安全目录被卸载: 
			在U盘总启动一个进程, 把U盘拔了, 进程无法正常运行
		chdir();
- 4. 修改umask掩码	-> 不是
		umask();
- 5. 关闭/重定向文件描述符	-> 不是
		- 标准输入 -> close(0)
		- 标准输出 -> close(1)
		- 标准错误 -> close(2)
		- 重定向: 设备文件: /dev/null ->int fd = open("/dev/null", O_RDWR);
            dup2(0, fd)
- 6. 核心操作流程 -> 是
```

## 1.5 练习

> 写一个守护进程, 每隔2s获取一次系统时间,  将这个时间写入到磁盘文件.



# 2. 线程

> 线程是轻量级的进程（LWP：light weight process），在Linux环境下线程的本质仍是进程。
>
> 操作系统会以进程为单位，分配系统资源，所以我们也说，进程是资源分配的最小单位。线程是操作系统调度执行的最小单位.
>
> - 每个进程对应一个虚拟地址空间
> - 多个子线程和父线程共用同一个虚拟地址空间
> - 线程是从进程中分出去的, 多个线程共用同一个地址空间
>   - 进程会争抢cup资源
>     - 线程被内核当做了进程
>       - 线程也会争抢cpu资源
>
> 安装线程 man page，命令：
>
> `sudo apt-get install manpages-posix-dev`

- 查看线程的LWP号

  - ps -Lf 
  - 这是给内核看的

- 线程之间共享和非共享资源

  - 共享资源

    1. 文件描述符表

    2. 每种信号的处理动作   -> 信号捕捉到之后的回调函数

    3. 当前工作目录 

    4. 用户ID和组ID

    5. 内存地址空间 (.text/.data/.bss/heap/共享库)

  - 不共享资源

    1. 线程id   -> 无符号长整形

    2. 处理器现场和栈指针(内核栈)

    3. 独立的栈空间(用户空间栈)

    4.  errno变量

    5. 阻塞信号集

    6. 调度优先级 -> 线程的优先级

- 创建线程

  ```c
  // 程序中默认只有一个进程, fork -> 2个进程
  // 程序中默认只有一个进程, pthread_create -> 得到2个线程, 父(主)线程[就是原来的进程], 子线程
  #include <pthread.h>
  // pthread_t 线程id的类型, 无符号长整形
  int pthread_create(pthread_t *thread, const pthread_attr_t *attr,
                            void *(*start_routine) (void *), void *arg);
  	参数: 
  		- thread: 传出参数, 线程创建成功之后, 子线程的线程ID被写到该变量中
  		- attr: 设置线程属性, 一般使用默认值, NULL
  		- start_routine: 函数指针, 这个函数就是子线程的处理逻辑
  		- arg: 给第三个参数传参
  	返回值:
  		成功: 0, 失败: 错误号, 这个错误号和之前的errno不一样
  		打印错误信息: char *strerror(int errnum);
  
  $ gcc pthread_create.c 
  /tmp/ccVvnhFB.o: In function `main':
  pthread_create.c:(.text+0x78): undefined reference to `pthread_create'
  collect2: error: ld returned 1 exit status
  // 在编译程序的时候需要添加线程库的名字 pthread
  gcc pthread_create.c -lpthread
  ```

- 获取当前线程的线程ID

  ```c
   #include <pthread.h>
  // 返回线程ID
  pthread_t pthread_self(void);
  ```

- 线程退出

  ```c
  // 当前线程退出, 不会影响其他线程的正常运行
  #include <pthread.h>
  void pthread_exit(void *retval);
  	- 参数: retval, 线程退出时候的返回值
  ```

  

- 回收子线程资源

  ```c
  #include <pthread.h>
  // 这是个阻塞函数, 调用一次回收一个子线程
  // 这个函数在主线程(父线程)中使用
  int pthread_join(pthread_t thread, void **retval);
  	参数:
  		- thread: 要回收的子线程的线程ID
  		- retval: 使用这个变量接收子线程退出的时候返回的值
  ```

- 线程分离

  ```c
  // 如果设置了线程分离, 子线程结束之后, 对应的资源不需要父线程释放
  // 如果设置了线程分离, 如果在调用 pthread_join 该函数会报错
  #include <pthread.h>
  int pthread_detach(pthread_t thread);
  	- thread: 子线程线程ID
  ```

- 线程取消

  ```c
  // 在父线程(主线程)中调用了线程取消函数, 可以终止某个子线程的运行
  // 该函数调用之后, 并不能马上终止子线程, 当子线程的处理函数运行到一个取消点的位置, 线程就终止了
  // 如果没有取消点, 子线程是不会被终止的
  // 取消点: 在程序中有从用户区到内核区的切换, 这个位置称之为取消点
  #include <pthread.h>
  // 在父线程中
  int pthread_cancel(pthread_t thread);
  	- thread: 子线程的线程ID
  ```

- 比较线程ID是否相同

  ```c
  // 在linux下线性ID - 无符号长整形
  // 在不同的平台下, pthread_t 封装有可能不同, 有些平台下 pthread_t 是一个结构体
  #include <pthread.h>
  int pthread_equal(pthread_t t1, pthread_t t2);
  	返回值:
  		相同: 非0值, 不同: 0
  ```

```c
// 验证线程直接是否共享全局变量
// n个线程, 交替数数, 每个线程数1000个数
   - 数的复杂一些
   		a = 10;
		a += 100
        a -= 100
        a++;
```



# 3. 线程属性

- 需要属性的变量 -> 对应一块内存

- 首先要申请一块内存, 并且初始化, 保存属性信息

- 当属性信息对应的变量使用完毕, 需要释放

  ```c
  // 线程属性类型
   pthread_attr_t t;
  // 初始化
  #include <pthread.h>
  int pthread_attr_init(pthread_attr_t *attr);
  // 释放资源
  int pthread_attr_destroy(pthread_attr_t *attr);
  // 通过设置属性实现线程分离
  int pthread_attr_setdetachstate(pthread_attr_t *attr, int detachstate);
  	- detachstate:
  		PTHREAD_CREATE_DETACHED: 设置线程分离
  		PTHREAD_CREATE_JOINABLE: 设置父子线程不分离
  ```

// 

# 进程信号集操作总结

![](assets/进程状态.png)

- 文件属性函数

  ```c
  // 判断文件权限, 或者文件是否存在
  int access(const char *pathname, int mode);
  	参数:
  		- pathname: 文件名
  		- mode: 
  			R_OK: 判断文件是不是有读权限
  			W_OK: 判断文件是不是有写权限
  			X_OK: 判断文件是不是有执行权限
  			F_OK: 判断当前文件是否存在
  	返回值:
  		判断成功: 0, 失败: -1
              
  // 修改文件权限
  int chmod(const char *filename, int mode);
  	参数:
  		- filename: 要修改文件权限的文件的名字
  		- mod: 八进制数
  // 修改文件所有者
  int chown(const char *path, uid_t owner, gid_t group);
  	参数:
  		- path: 要修改的文件名
  		- owner: 用户ID, stat /etc/passwd
  		- group: 组ID    /etc/group
  // 修改文件大小
  int truncate(const char *path, off_t length);
  	参数: 
  		- path: 要操作的文件
  		- length: 最终的文件大小
  ```

- 目录操作函数

  ```c
  // 文件重命名
  int rename(const char *oldpath, const char *newpath);
  	参数: 
  		- oldpath: 旧的文件名
  		- newpath: 新的文件名
  		
  // 修改进程的工作目录
  // 在 /home/itcat启动a.out, a.out的工作目录 /home/itcast
  // chdir("/") -> 进程切换到了根目录
  int chdir(const char *path);
  // == pwd命令
  char *getcwd(char *buf, size_t size);
  	参数: 
  		- buf: 存储路径, 指向一个由内存大小的数组
  		- size: 修饰buf大小
  	返回值:
  		指针指向一块内存, 这个内存就是第一个参数
  // 创建目录
  // 如果创建目录, 这个目录必须要有执行权限
  int mkdir(const char *pathname, mode_t mode);
  	参数:
  		- pathname: 目录名
  		- mode: 目录的权限 mod & ~umask
  // == rmdir命令, 只能删除空目录 rm -r
  int rmdir(const char *pathname);
  ```