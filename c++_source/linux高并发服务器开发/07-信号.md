# 1. 信号相关的概念

- 信号的特点

  - 简单
  - 携带的信息量很少

- Linux中的信号

  - Linux系统的消息机制
  - 信号的优先级非常高
  - 完成进程通信
    - 不要使用

- 产生信号的场景

  为了理解信号，先从我们最熟悉的场景说起：

  > 1. 用户输入命令，在Shell下启动一个前台进程。			
  >
  > 2. 用户按下Ctrl-C，这个键盘输入产生一个硬件中断。
  >
  > 3. 通过kill命令终止某一个进程。
  >
  >    kill -9 PID
  >
  > 4. 如果CPU当前正在执行这个进程的代码，则该进程的用户空间代码暂停执行，CPU从用户态切换到内核态处理硬件中断。
  >
  >    程序中调用了  sleep();
  >
  > 5. 正在运行的程序访问了非法内存，发生段错误，进程退出。

  ```shell
  # 1, 2 的信号是通过对终端的操作产生的
  # 3 通过shell命令产生了信号
  # 4 通过函数调用产生了信号
  # 5 硬件错误   
  ```

- 察看系统定义的信号列表

  ```shell
  $ kill -l
   1) SIGHUP       2) SIGINT       3) SIGQUIT      4) SIGILL       5) SIGTRAP
   6) SIGABRT      7) SIGBUS       8) SIGFPE       9) SIGKILL     10) SIGUSR1
  11) SIGSEGV     12) SIGUSR2     13) SIGPIPE     14) SIGALRM     15) SIGTERM
  16) SIGSTKFLT   17) SIGCHLD     18) SIGCONT     19) SIGSTOP     20) SIGTSTP
  21) SIGTTIN     22) SIGTTOU     23) SIGURG      24) SIGXCPU     25) SIGXFSZ
  26) SIGVTALRM   27) SIGPROF     28) SIGWINCH    29) SIGIO       30) SIGPWR
  31) SIGSYS      34) SIGRTMIN    35) SIGRTMIN+1  36) SIGRTMIN+2  37) SIGRTMIN+3
  38) SIGRTMIN+4  39) SIGRTMIN+5  40) SIGRTMIN+6  41) SIGRTMIN+7  42) SIGRTMIN+8
  43) SIGRTMIN+9  44) SIGRTMIN+10 45) SIGRTMIN+11 46) SIGRTMIN+12 47) SIGRTMIN+13
  48) SIGRTMIN+14 49) SIGRTMIN+15 50) SIGRTMAX-14 51) SIGRTMAX-13 52) SIGRTMAX-12
  53) SIGRTMAX-11 54) SIGRTMAX-10 55) SIGRTMAX-9  56) SIGRTMAX-8  57) SIGRTMAX-7
  58) SIGRTMAX-6  59) SIGRTMAX-5  60) SIGRTMAX-4  61) SIGRTMAX-3  62) SIGRTMAX-2
  63) SIGRTMAX-1  64) SIGRTMAX
  ```

- 查看信息的详细信息

  ```shell
  man 7 signal
  # linux中信号的行为 -> 进程收到这个信号之后的处理动作
  Term   终止进程
  Ign    当前进程忽略掉这个信号
  Core   终止进程, 并且声称一个core文件, core文件是gdb调试的时候使用的
  		- 默认情况下, 操作系统不允许声称core文件
  		- ulimit -a
  			core file size          (blocks, -c) 0 -> 文件大小为0, 不允许
  		- 放开系统限制:
  			ulimit -c 文件大小(int)/unlimited
  Stop   暂停当前进程
  Cont   继续执行当前被暂停的进程
  ```

- 信号的几种状态

  ```shell
  1. 产生	2. 未决(没有被处理)	3. 递达(被处理了)
  阻塞是未决的一种特殊状态
  ```

- 可选的信号处理动作

  ```shell
  # 进程收到信号之后, 如果对信号进行处理:
  1. 执行信号的默认处理动作     2. 忽略(信息的默认动作不是忽略) 	3. 执行用户的自定义操作
  第2, 3点需要对信号进行捕捉
  
  The signals SIGKILL and SIGSTOP cannot be caught, blocked, or ignored.
  - SIGKILL, SIGSTOP 不允许被捕捉, 阻塞和忽略
  ```

# 2. 信号相关的函数

- kill/raise/abort

  ```c
  #include <sys/types.h>
  #include <signal.h>
  // 通过这个函数给某个进程发送信号
  int kill(pid_t pid, int sig);
  	参数: 
  		- pid:
  			>0: 将信号发送给指定的进程  -> 最常用
  			=0: 将信号发送给当前的进程组
  			-1: 将信号发送给每一个有权限接收这个信号的进程
  			<1: 这个pid=某个进程组的ID(1234)取反(-1234), 
  					信号发送给了ID为1234的进程中的每一个进程
  		- sig: 要送的的信号(宏值/整数)
      kill(getppid(), 9);
  ```

  ```c
  #include <signal.h>
  // 给当前进程发信号
  int raise(int sig);
  	参数:	
  		- sig: 要发送的信号
  	返回值:
  		- 成功: 0
          - 失败: 非0
  // 使用kill实现raise
  kill(getpid(), sig);
  ```

  ```c
  #include <stdlib.h>
  // 发送 SIGABRT 给当前进程, 杀死当前进程
   void abort(void);
  // 使用kill实现abort函数
  kill(getpid(), SIGABRT);
  ```

- alarm

  ```c
  #include <unistd.h>
  // 函数调用, 开始倒计时, 当倒计时为0的时候, 函数会给当前进程发送一个信号: SIGALRM
  // SIGALRM -> 默认终止当前进程
  unsigned int alarm(unsigned int seconds);
  	参数: 
  		- seconds: 倒计时有多长, 单位: 秒, 如果该参数为0: 定时器无效(不倒计时, 不发信号)
      返回值: 倒计时剩余的时间
  // 取消倒计时
  alarm(100); -> 该函数不阻塞
  alarm(0);
  
  // 1秒中电脑能数多少个数?
  实际时间 = 内核时间 + 用户时间 + 消耗的时间
  进行文件IO操作的时候比较浪费时间
  ```

- setitimer

  ```c
  #include <sys/time.h>
  // 小明在晚上八点设置闹钟: 明天早晨7点起床[it_value], 闹钟每隔5分钟响一次[it_interval]
  struct itimerval {
  	struct timeval it_interval; // 第二次以及以后定时器每隔多长时间被触发一次, 频率
  	struct timeval it_value;    // 第一次触发定时器的时长, 倒计时的时长
  };
  
  // 总时间 = tv_sec + tv_usec
  struct timeval {
  	time_t      tv_sec;         // 秒
  	suseconds_t tv_usec;        // 微秒
  };
  
  // 可以实现周期性定时
  int setitimer(int which, const struct itimerval *new_val, struct itimerval *old_value);
  	参数: 
  		- which: 定时器以什么时间计时
  			ITIMER_REAL: 真实时间, 时间达到, 发送信号: SIGALRM   -> 常用
  			ITIMER_VIRTUAL: 用户时间, 时间达到, 发送信号: SIGVTALRM
  			ITIMER_PROF: 内核时间, 时间达到, 发送信号: SIGPROF
  		- new_val: 设置定时器的属性
  		- old_value: 记录了上一次定时器设置的属性信息, 一般不使用, 指定为NULL
  
  ```

  

# 3. 信号捕捉

## 3.1 信号捕捉函数

- signal

  ```c
  #include <signal.h>
  void func(int num)
  {
  }
  // int型参数 -> 捕捉到的信号的编号
  typedef void (*sighandler_t)(int);
  
  sighandler_t signal(int signum, sighandler_t handler);
  	参数: 
  		- signum: 要捕捉的信号
  		- handler: 回调函数
  signal(2, func);	
  回调函数:
  	- 需要程序猿实现, 函数类型根据实际需求, 看函数指针的定义
  	- 需要程序猿调用, 系统/框架调用
  	- 函数指针是实现回调的手段, 函数实现之后, 将函数名 放到 函数指针的位置上就行了
  ```

- sigaction

  ```c
  // posix
  #include <signal.h>
  struct sigaction {
  	void     (*sa_handler)(int);	// 函数指针, 指向的函数就是信号捕捉到之后的处理函数
  	void     (*sa_sigaction)(int, siginfo_t *, void *);	// 不常用
  	sigset_t   sa_mask;	// 临时阻塞信号集, 在信号捕捉函数执行过程中, 临时阻塞某些信号
  	int        sa_flags;	// 使用哪个函数指针进行捕捉到信号的处理动作
  	void     (*sa_restorer)(void);	// 被废弃了
  };
  
  sa_flags = 0, 默认值, 使用: sa_handler
  sa_flags = SA_SIGINFO, 使用: sa_sigaction
  int sigaction(int signum, const struct sigaction *act,
                       struct sigaction *oldact);	
  	参数: 
  	 - signum: 要捕捉的信号
  	 - act: 捕捉到信号之后的处理动作
  	 - oldact: 上一次对信号捕捉的相关设置, 不使用-> NULL
  	返回值: 
  	  成功: 0, 失败: -1
  ```

## 3.2 信号传参(自行学习)

```c
// 将信号发送到某个进程
kill();
// 将信号发送到某个进程, 并传递一些额外的数据
union sigval {
	int   sival_int;	// 两个没有血缘关系的进程间通信
	void *sival_ptr;	// 有血缘关系
};
int sigqueue(pid_t pid, int sig, const union sigval value);

// 信号捕捉 -> sigaction
struct sigaction {
	void     (*sa_handler)(int);	// 函数指针, 指向的函数就是信号捕捉到之后的处理函数
	void     (*sa_sigaction)(int, siginfo_t *, void *);	// 不常用
	sigset_t   sa_mask;	// 临时阻塞信号集, 在信号捕捉函数执行过程中, 临时阻塞某些信号
	int        sa_flags;	// 使用哪个函数指针进行捕捉到信号的处理动作
	void     (*sa_restorer)(void);	// 被废弃了
};
struct sigaction act;
act.sa_flags = SA_SIGINFO;
act.sa_sigaction = xxx;
```

## 3.2 内核实现信号捕捉的过程

![1557484175573](assets/kernel.png)

## 3.3 信号捕捉的特性

> 1. 进程正常运行时，默认PCB中有一个阻塞信号集，假定为 block_mask，它决定了进程自动屏蔽哪些信号。当注册了某个信号捕捉函数，捕捉到该信号以后，要调用该函数。而该函数有可能执行很长时间，在这期间所屏蔽的信号不由 block_mask 来指定。而是用sa_mask来指定。调用完信号处理函数，再恢复为 block_mask。
>
>    ​	- sigaction ->  sa_mask
>
> 2.  XXX信号捕捉函数执行期间，XXX信号自动被屏蔽。
>
>    act.sa_handler = myalrm;	// 在myalarm执行期间, 自动屏蔽2号信号, 不需要设置, 执行完成, 屏蔽解除
>
>    sigmask(2, &act, NULL);
>
>    
>
> 3. 阻塞的常规信号不支持排队，产生多次只记录一次。（后32个实时信号支持排队）。
>
>    未决信号集中每个信号只有一标志位, 因此只能标记一次的状态 0, 1

# 3. 信号集

## 3.1 阻塞信号集/未决信号集

> 在PCB中有两个非常重要的信号集。一个称之为“阻塞信号集”，另一个称之为“未决信号集”。这两个信号集都是内核使用位图机制来实现的。但<font color="blue">操作系统不允许我们直接对这两个信号集进行位操作。而需自定义另外一个集合，借助信号集操作函数来对PCB中的这两个信号集进行修改</font>。
>
> <font color="red">信号的 “未决” 是一种状态，指的是从信号的产生到信号被处理前的这一段时间。</font>
>
> <font color="red">信号的 “阻塞” 是一个开关动作，指的是阻止信号被处理，但不是阻止信号产生。</font>
>
> <font color="red">信号的阻塞就是让系统暂时保留信号留待以后发送。</font>由于另外有办法让系统忽略信号，所以一般情况下信号的阻塞只是暂时的，只是为了 防止信号打断敏感的操作。

![1557559841592](assets/1557559841592.png)

```shell
1. 用户通过键盘 ctrl+c -> 产生2号信号 sigint (信号被创建)
2. 信号产生但是没有被处理-> 未决
	- 在内核中将所有没有被处理信号存储在一个表中 -> 未决信号集
	- sigint信号状态被存储在 第二个标志位上
		- 这个标志位值 == 0, 这个信号不是未决状态
		- 标志位 == 1, 这个信号处于未决状态
3. 这个未决状态的信号, 需要被处理, 处理之前需要和另一个信号集(阻塞信号集)进行比较
	- 阻塞信号集中默认不阻塞任何信号
	- 如果小阻塞某些信号需要用户设置的 -> 调用 系统的 API
	
4. 在处理的时候和阻塞信号集中的这个标志位进行查询, 看是不是对该信号设置了阻塞
	- 如果设置了阻塞: 这个信号继续处于未决状态, 直到解除阻塞, 这个信号就被处理了
	- 如果没有设置阻塞: 这个信号直接被处理掉了
```

## 3.2 信号集相关函数

```c
// 前四个函数返回0->成功, -1->失败
#include <signal.h>
// 清空信号集
// 信号集所有的标志位的值设置为0
int sigemptyset(sigset_t *set);
	- set: 自定义的信号集
// 信号集所有的标志位的值设置为1
int sigfillset(sigset_t *set);
// 在信号集中, 添加阻塞的信号
int sigaddset(sigset_t *set, int signum);
	- set: 自定义信号集
	- signum: 将那个信号设置到信号集中, 阻塞这个信号
// 将某个信号从设置好的信号集中删除
int sigdelset(sigset_t *set, int signum);

// 判断某个信号是否已经设置到了自定义的信号集中
int sigismember(const sigset_t *set, int signum);
	- set: 自定义的信号集
	- signum: 某一个信号的编号/信号对应的宏
	返回值:
		1: 判断的信号在信号集中
		0: 判断的信号没有在信号集中
		-1: 失败
	
// 将自定义信号中的数据设置到内核中
// 修改是内核的阻塞信号集
int sigprocmask(int how, const sigset_t *set, sigset_t *oldset);
	参数: 
		- how: 如何对内核阻塞信号集进行处理
			SIG_BLOCK: 将用户设置的阻塞信息添加到内核中, 内核中原来的数据不变
				假设内核中默认的信号集mask, mask |= set
			SIG_UNBLOCK: 清除用户在内核中设置的数据, mask &= ~set
			SIG_SETMASK: 覆盖内核中原来的值
		- set: 已经初始化完成的自定义的阻塞信号集
		- oldset: 保存设置之前内核中阻塞信号集的状态

// 读内核的未决信号集
int sigpending(sigset_t *set);
	- set: 传出参数, 保存了内核未决信号集中的信息
	
// 编写程序，把所有常规信号(1-31)的未决状态打印至屏幕。
// 设置某些信号是阻塞的, 通过键盘操作产生这些信号
```



# 5. SIGCHLD信号

## 5.1 SIGCHLD的产生条件

```shell
1. 子进程死了, 自杀, 他杀
2. 子进程被暂停了
3. 子进程由暂停状态重新恢复运行
以上三种情况子进程都会给父进程发送信号: SIGCHLD, 父进程默认会忽略这个信号
# 在父进程中拦截该信号 -> 写处理函数( 回收子进程资源 )

// 错误写法
int main()
{
	pid_t pid = fork();
	if(pid > 0)
	{
		wait/waitpid():
	}
}

ps aux
```

## 5.2 使用SIGCHLD回收子进程