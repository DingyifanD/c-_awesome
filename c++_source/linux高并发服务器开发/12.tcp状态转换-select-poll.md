# 1. TCP状态转换

![](assets/20141015155713390.png)

```c
/*
	三次握手之前:
		服务器端: 
			- 先启动, 并设置监听 -> listen()
				- 状态: LISTEN
*/

/*
	三次握手开始:
		第一次握手:
			- 客户端调用 connect() 函数, 状态: SYN_SENT
		第二次握手:
			- 服务器端接受连接请求, 状态: SYN_RCVD
			- 客户端: 连接请求被接受, 状态: ESTABLISHED
		第三次握手:
			- 服务器的的连接请求被客户端接受: 状态: ESTABLISHED
*/
// 通信的双方必须都变成: ESTABLISHED 状态之后才可以正常通信.

/*
	四次挥手:
		第一次挥手:
			主动断开连接的一方:
				- 调用了 close() 函数: 状态: FIN_WAIT_1
			被动断开连接的一方:
				- 状态: CLOSE_WAIT
		第二次挥手:
			主动断开连接的一方:
				- 状态: FIN_WAIT_2
		第三次挥手:
			被动断开连接的一方:
				- 调用函数 close(), 状态: LAST_ACK
			主动断开连接的一方:
				- 状态: TIME_WAIT
		第四次挥手:
			当被动接受连接的一方, 收到, 主动断开连接一方的ACK之后, 就死了
				
*/
```



![](assets/wKiom1ZLIP2CRdNUAAlNCKgqwI0818.jpg)

- 2MSL（Maximum Segment Lifetime）

  主动断开连接的一方, 最后进出入一个 TIME_WAIT状态, 这个状态会持续: 2msl

  - msl: 官方建议: 2分钟, 实际是30s

  > 当TCP连接主动关闭方接收到被动关闭方发送的FIN和最终的ACK后，连接的主动关闭方必须处于TIME_WAIT状态并持续2MSL时间。
  >
  > 这样就能够让TCP连接的主动关闭方在它发送的ACK丢失的情况下重新发送最终的ACK。
  >
  > 主动关闭方重新发送的最终ACK并不是因为被动关闭方重传了ACK（它们并不消耗序列号，被动关闭方也不会重传），而是因为被动关闭方重传了它的FIN。事实上，被动关闭方总是重传FIN直到它收到一个最终的ACK。

- 半关闭

  > 当TCP链接中A向B发送 FIN 请求关闭，另一端B回应ACK之后，并没有立即发送 FIN 给A, A方处于半连接状态（半开关），此时A可以接收B发送的数据，但是A已经不能再向B发送数据。

  ```c
  // 主动断开连接的一方A调用close()函数, 另一方B没有调用close
  //      -> A的写被关闭了, 读还留着
  //      -> B的读写都还留着
  
  // 半关闭函数
  #include <sys/socket.h>
  int shutdown(int sockfd, int how);
  	参数: 
  		- sockfd: 要操作的文件描述符
  		- how: 操作方式
  			- SHUT_RD: 关闭读
  			- SHUT_WR: 关闭写
  			- SHUT_RDWR: 关闭读写	
  ```

  

- 查看网络相关信息命令

  ```shell
  $ netstat
  	○ 参数：
  		-a (all)显示所有选项，默认不显示LISTEN相关
  		-p 显示建立相关链接的程序名
  		-n 拒绝显示别名，能显示数字的全部转化成数字。
  		-l 仅列出有在 Listen (监听) 的服务状态
  		-t (tcp)仅显示tcp相关选项
  		-u (udp)仅显示udp相关选项
  ```

  

# 2. 端口复用

> 端口复用最常用的用途是:
>
> - 防止服务器重启时之前绑定的端口还未释放
> - 程序突然退出而系统没有释放端口

```c
#include <sys/types.h> 
#include <sys/socket.h>
// 设置套接字属性
int setsockopt(int sockfd, int level, int optname, const void *optval, socklen_t optlen);
	参数:
		- sockfd: 要操作的文件描述符
		- level: 级别 -> SOL_SOCKET (端口复用的级别)
        - optname: 端口复用的级别(二选一)
        	- SO_REUSEADDR
        	- SO_REUSEPORT
        - optval: 端口复用-> 对应的是整形数
        	- 1: 可以复用
        	- 0: 不能复用
        - optlen: optval参数对应的内存大小

// 设置端口复用, 设置的时机: 服务器绑定端口之前, 设置端口复用
setsockopt();
bind();
```



# 3. IO多路转接

```c
/*
	使用进程/线程方式实现并发:
		- 共同点: 
			有一个父亲线程/进程 -> accept 某些情况下是阻塞的
			子进程/子线程   -> 通信 -> read/write 某些情况下是阻塞的
		- 不同点:
			线程更节省系统资源, 一般写程序, 考虑线程的实现方式
			在一个进程中, 调用另一个进程 -> exec
*/
改进思路: 所有的阻塞状态, 程序猿都不去判断, 委托内核判断, 得到内核回复之后进行后续处理
	- 程序猿是不能直接操作内核, 间接 -> 使用系统函数
		- select
		- poll
		- epoll
```

> **不再由应用程序自己监视客户端连接和数据通信，取而代之由内核替应用程序监视文件。**

## 3.3 select

> 主旨思想:
>
> - 先构造一张有关文件描述符的列表, 将要监听的文件描述符添加到该表中
>
> - 调用一个函数,监听该表中的文件描述符,直到这些描述符表中的一个进行I/O操作时，该函数才返回。
>
> - - 该函数为阻塞函数
>   - 函数对文件描述符的检测操作是由内核完成的
>
> - 在返回时，它告诉进程有多少(哪些)描述符要进行I/O操作。

```c
// 相关函数
#include <sys/time.h>
#include <sys/types.h>
#include <unistd.h>
// sizeof(fd_set) = 128
int select(int nfds, fd_set *readfds, fd_set *writefds,
                  fd_set *exceptfds, struct timeval *timeout);
	参数:
		- nfds: 委托内核检测的最大文件描述符的值 + 1
        - readfds: 读集合, 委托内核检测哪些文件描述符的读属性
        	- 一般检测读操作
        	- 对的是对方发送过来的数据, 因为读是被动的接收数据
        		- 因此需要时时检测对应读缓冲区
        	- 这是一个传入传出的参数
        - fd_set: 写集合, 委托内核检测哪些文件描述符的写属性
        	- 这是一个传入传出的参数
        	- 委托内核检测写缓冲区是不是还可以写数据(不满就可以写)
        - exceptfds: 异常集合, 委托内核检测哪些文件描述符出现了异常
       	- timeout:
			struct timeval {
               long    tv_sec;         /* seconds */
               long    tv_usec;        /* microseconds */
           };
			- NULL: 永久阻塞, 直到检测到了文件描述符有变化
			- tv_sec = 0, tv_usec = 0, 不阻塞
			- tv_sec > 0 || tv_usec > 0, 阻塞对应的时间长度
	返回值:
		-1: 失败
		>0(n): 检测的集合中有n个文件描述符发送的变化 

// 将参数文件描述符fd对应的标志位, 设置为0
void FD_CLR(int fd, fd_set *set);
// 判断fd对应的标志位到底是0还是1, 返回值: fd对应的标志位的值, 0, 返回0, 1->返回1
int  FD_ISSET(int fd, fd_set *set);
// 将参数文件描述符fd对应的标志位, 设置为1
void FD_SET(int fd, fd_set *set);
// fd_set 共有1024bit, 全部初始化为0
void FD_ZERO(fd_set *set);
```

![1558346304301](assets/1558346304301.png)

![1558346328481](assets/1558346328481.png)

## 3.4 poll

- 函数

  ```c
  #include <poll.h>
  struct pollfd {
  	int   fd;         /* 委托内核检测的文件描述符 */
  	short events;     /* 委托内核检测文件描述符的什么事件 */
  	short revents;    /* 文件描述符实际发生的事件 */
  };
  struct pollfd myfd;
  myfd.fd = 5;
  myfd.events = POLLIN | POLLOUT;
  
  struct pollfd myfd[100];
  int poll(struct pollfd *fds, nfds_t nfds, int timeout);
  	参数:
  		- fds: 这是一个struct pollfd数组, 这是一个要检测的文件描述符的集合
  		- nfds: 这是第一个参数数组中最后一个有效元素的下标 + 1
          - timeout: 阻塞时长
          	0: 不阻塞
          	-1: 阻塞, 检测的fd有变化解除阻塞
          	>0: 阻塞时长
        返回值:
  		-1: 失败
  		>0(n): 检测的集合中有n个文件描述符发送的变化 
  ```

  

  ![1558308141721](assets/1558308141721.png)

