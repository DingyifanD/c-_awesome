# 1. Libevent介绍

![](assets/未命名图片.png)

- 特点 

  > Libevent 是一个用C语言编写的、轻量级的开源高性能事件通知库，主要有以下几个亮点：
  >
  > - 事件驱动（ event-driven），高性能;
  > - 轻量级，专注于网络；
  > - 源代码相当精炼、易读；
  > - 跨平台，支持 Windows、 Linux、 BSD（是Unix的衍生系统） 和 Mac OS；
  > - 支持多种 I/O 多路复用技术， epoll、 poll、 select 和 kqueue 等；
  > - 支持 I/O，定时器和信号等事件；
  > - 支持注册事件优先级。

- 安装

  ```shell
  # 下载地址: http://libevent.org/
  # 安装步骤 -> 源码安装的方式
  	1. 找 可执行程序: configure
  		./configure # 检测安装环境, 并且声称一个makefile
  	2. 根据makefile中的构建规则编译源代码
  		make # 得到可执行程序/动态库/静态库
  	3. 安装
  		sudo make install # 将得到可执行程序/动态库/静态库/头文件拷贝到系统目录
  
  # 动态库找不到问题解决
  1. 通过find命令查找对应的库的位置
  	find 搜索目录 -name "libevent.so"
  		得到结果: /usr/local/lib/libevent.so
  2. 通过vi 打开/etc/ld.so.conf文件
  	sudo /etc/ld.so.conf
  	将/usr/local/lib/放到文件的最后一行, 保存
  3. 执行命令: sudo ldconfig
  
  # 编译  hello.c
  gcc hello.c -o hello -levent
  ```

# 2. 事件处理框架 - event_base

> 使用 libevent函数之前需要分配一个或者多个 event_base 结构体。每个event_base 结构体持有一个事件集合，可以检测以确定哪个事件是激活的。每个 event_base 都有一种用于检测哪种事件已经就绪的 “方法”，或者说后端。 

- API函数

  ```c
  // 头文件
  #include <event2/event.h>
  // 操作函数
  struct event_base * event_base_new（void）;
  void event_base_free（struct event_base * base）;
  
  // 检查event_base的后端方法
  const char** event_get_supported_methods(void）;
  const char *event_base_get_method(const struct event_base *base);
  ```

- event_base和fork

  ```c
  /*
  	○ 子进程创建成功之后, 父进程可以继续使用event_base
  	○ 子进程中需要继续使用event_base需要重新进程初始化
  */
  int event_reinit(struct event_base* base);
  ```

  

# 3. 事件循环

> event_base不停的检测委托的检测是实际是不是发生了, 如果发生了, event_base会调用对应的回调函数, 这个回调函数的用户委托检测事件的时候给的.

- 设置事件循环

  ```c
  // 头文件
  #include <event2/event.h>
  
  // 操作函数
  #define EVLOOP_ONCE 			0x01
  #define EVLOOP_NONBLOCK 		0x02
  #define EVLOOP_NO_EXIT_ON_EMPTY 0x04
  int event_base_loop(struct event_base *base, int flags);
  	参数:
  		- base: 通过 event_base_new（void）得到的
  		- flags:
  			- EVLOOP_ONCE: 一直检测某个事件, 当事件被触发了, 停止事件循环
  			- EVLOOP_NONBLOCK: 非阻塞的方式检测, 当事件被触发了, 停止事件循环
  			- EVLOOP_NO_EXIT_ON_EMPTY: 一直进行事件检测, 如果没有要检测的事件, 不退出
  
  // 如果委托了event_base检测某些事件, 不停的进行循环检测
  // 什么时候结束检测: 所有要检测的事件都被触发, 并且处理完毕
  int event_base_dispatch(struct event_base* base);	// 一般使用这个函数
  ```

  

- 终止事件循环

  ```c
  // 头文件
  #include <event2/event.h>
  
  struct timeval {
  	long    tv_sec;                    
  	long    tv_usec;    // 微秒        
  };
  // 在 tv 时长之后退出循环, 如果这个参数为空NULL, 直接退出事件循环
  // 事件循环: 检测对应的事件是否被触发了
  // 如果事件处理函数正在被执行, 执行完毕之后才终止
  int event_base_loopexit(struct event_base * base, const struct timeval * tv);
  // 马上终止
  int event_base_loopbreak(struct event_base * base);
  ```

  

# 4. 事件

- 事件的创建、添加、删除

  ```c
  // 头文件
  #include <event2/event.h>
  
  #define EV_TIMEOUT 	0x01
  #define EV_READ 	0x02
  #define EV_WRITE 	0x04
  #define EV_SIGNAL 	0x08
  #define EV_PERSIST 	0x10	// 修饰某个事件是持续触发的
  #define EV_ET 		0x20	// 边沿模式
  
  typedef void (*event_callback_fn)(evutil_socket_t，short，void *);
  	参数:
  		- 第一个参数: event_new的第二个参数
  		- 第二个参数: 实际触发的事件
  		- 第三个参数: event_new的最后一个参数
  // 创建事件
  struct event* event_new(struct event_base * base，evutil_socket_t fd，
       					 short what，event_callback_fn cb，void * arg);
  	参数:
  		- base: event_base_new（void)得到的
  		- fd: 文件描述符, 检测这个fd对应的事件
  		- what: 监测fd的什么事件, 在上边
  		- cb: 回调函数, 当前检测的事件被触发, 这个函数被调用
  		- arg: 给回调函数传参
  // 释放事件资源
  void event_free(struct event * event);
  // 添加事件
  // 事件被new出之后, 不能直接被event_base进行检测
  // event_add之后event_base就可以对事件进行检测
  int  event_add(struct event * ev，const  struct timeval * tv);
  	参数: tv-> 超时时间, 如果这个值> 0, 比如 == 3
          检测fd的读事件, 在三秒之内没有触发该事件 -> 超时
          超时之后, 事件对应的回调函数会被强制调用
          如果该参数为NULL, 不会做超时检测
  // 删除要检测的事件
  int  event_del(struct event * ev);
  ```

- 事件的优先级设置

  ```c
  // 头文件
  #include <event2/event.h>
  // EVENT_MAX_PRIORITIES == 256
  // 初始化事件优先级有多少级
  int event_base_priority_init(struct event_base * base，int n_priorities);
  	参数:
  		- n_priorities: 等级的个数, 假设 == 6
             也就是说有6个等级: 0,1,2,3,4,5, 0优先级最高
  
  // 获取当前可用的等的个数
  int event_base_get_npriorities(struct event_base * base);
  // 给事件设置等级
  int event_priority_set(struct event *event, int priority);
  	参数:
  		- event: 创建的事件
  		- priority: 要设置的等级
  ```

  

# 5. 带缓冲区的事件

- 概念理解

  > 1. bufferevent 理解:
  >    - 是libevent为IO缓冲区操作提供的一种通用机制
  >    - bufferevent 由一个底层的传输端口(如套接字 ),  一个读取缓冲区和一个写入缓冲区组成。
  >    - 与通常的事件在底层传输端口已经就绪, 可以读取或者写入的时候执行回调不同的是, bufferevent在读取或者写入了足够量的数据之后调用用户提供的回调。
  >
  > 2. 回调 - 缓冲区对应的操作
  >
  > 1. - 每个 bufferevent 有两个数据相关的回调
  >
  >    - - 读取回调: 从底层传输端口读取了任意量的数据之后会调用读取回调(默认)
  >      - 写入回调: 输出缓冲区中足够量的数据被清空到底层传输端口后写入回调会被调用(默认)

- 创建/释放基于套接字的bufferevent

  ```c
  // 主要应用于网络套接字通信   -> socket()
  struct bufferevent *bufferevent_socket_new(
  	struct event_base *base,
  	evutil_socket_t fd,
  	enum bufferevent_options options
  ); 
  	参数:
  		- base: 处理事件的
  		- fd: 通信的文件描述符
  		- options: BEV_OPT_CLOSE_ON_FREE -> 自动释放底层资源
  	返回值: 得到带缓冲区的事件变量
  // 释放资源
  void bufferevent_free(struct bufferevent *bev);
  ```

  

- 在bufferevent上启动链接

  ```c
  /*
  	1. 如果还没有为bufferevent 设置套接字,调用函数将为其分配一个新的流套接字,并且设置为非阻塞的
  		bufferevent_socket_new(base, -1, BEV_OPT_CLOSE_ON_FREE);
  	2. 如果已经为 bufferevent 设置套接字,调用bufferevent_socket_connect() 将告知 libevent 
  	   套接字还未连接,直到连接成功之前不应该对其进行读取或者写入操作。
  	3. 连接完成之前可以向输出缓冲区添加数据。
  */
  // 连接服务器函数
  int bufferevent_socket_connect(
  	struct bufferevent *bev,
  	struct sockaddr *address,
  	int addrlen
  ); 
  	参数:
  		- bev: 带缓冲区的事件, 里边封装 fd
  		- address: 要连接的服务器的IP和端口
  		- addrlen: address结构体的内存大小
  ```

  

- bufferevent读写缓冲区回调操作

  ```c
  typedef void (*bufferevent_data_cb)(struct bufferevent *bev, void *ctx);
  	参数:
  		- bev: 从bufferevent_setcb函数中的第一个参数传入的
  		- ctx: 从bufferevent_setcb函数中的最后第一个参数传入的
  		
  typedef void (*bufferevent_event_cb)(struct bufferevent *bev, short events, void *ctx);
  	参数:
  		- bev: 从bufferevent_setcb函数中的第一个参数传入的
  		- events: 可以检测到的事件
  			EV_EVENT_READING：读取操作时发生某事件，具体是哪种事件请看其他标志。
  			BEV_EVENT_WRITING：写入操作时发生某事件，具体是哪种事件请看其他标志。
  			BEV_EVENT_ERROR：操作时发生错误。关于错误的更多信息，请调用 EVUTIL_SOCKET_ERROR()。
  			BEV_EVENT_TIMEOUT：发生超时。
  			BEV_EVENT_EOF：遇到文件结束指示。
  			BEV_EVENT_CONNECTED：请求的连接过程已经完成 
  
  void bufferevent_setcb(struct bufferevent *bufev, 
         					bufferevent_data_cb readcb, 		
         					bufferevent_data_cb writecb, 
                         	bufferevent_event_cb eventcb, void *cbarg
  );
  	参数:
  		- bufev: 带缓冲区的事件
  		- readcb: 读事件触发之后的回调函数
  		- writecb: 写事件触发之后的回调函数
  		- eventcb: 特殊事件的回调函数
  		- cbarg: 给回调函数传参
  ```

  

- 禁用、启用缓冲区

  ```c
  /*
  	可以启用或者禁用 bufferevent 上的 EV_READ、EV_WRITE 或者 EV_READ | EV_WRITE 事件。
  	没有启用读取或者写入事件时, bufferevent 将不会试图进行数据读取或者写入。
  */
  100  110
  // 读写缓冲区, 写缓冲区默认是有效的
  // 设置某个事件有效
  void bufferevent_enable(struct bufferevent *bufev, short events); 
  // 设置某个事件无效
  void bufferevent_disable(struct bufferevent *bufev, short events);
  // 获取缓冲区对应的有效事件
  short bufferevent_get_enabled(struct bufferevent *bufev); 
  ```

  

- 操作bufferevent中的数据

  ```c
  // 向bufferevent的输出缓冲区添加数据
  int bufferevent_write(struct bufferevent *bufev, const void *data, size_t size);
  // 从bufferevent的输入缓冲区移除数据
  size_t bufferevent_read(struct bufferevent *bufev, void *data, size_t size);
  ```

  

# 6. 链接监听器

- 创建和释放evconnlistener

  ```c
  #include <event2/listener.h> 
  typedef void (*evconnlistener_cb)(
  			struct evconnlistener *listener,   
  			evutil_socket_t sock,   
  			struct sockaddr *addr, 
  			int len, 
  			void *ptr
  ); 
  	参数:
  		- listener: evconnlistener_new_bind 返回的地址
  		- sock: 用于通信的fd
  		- addr: 客户端的地址信息
  		- ptr: 外部传进来的参数, evconnlistener_new_bind的第三个参数
  		
  struct evconnlistener* evconnlistener_new(
  			struct event_base *base,
  			evconnlistener_cb cb, 
  			void *ptr, 
  			unsigned flags, 
  			int backlog,	// 监听的时候用的
  			evutil_socket_t fd	// 监听的并且已经绑定成功了
  );
  // 创建监听的套接字, 绑定, 设置监听, 等待并接受连接请求
  struct evconnlistener *evconnlistener_new_bind(
  			struct event_base *base,
  			evconnlistener_cb cb,	// 接受新连接之后
  			void *ptr, 
  			unsigned flags, 
  			int backlog,
  			const struct sockaddr *sa, // 本地的IP和端口
  			int socklen				   // struct sockaddr结构体大小
  );
  	参数:
  		- flags:
  			LEV_OPT_CLOSE_ON_FREE: 自动关闭底层套接字
  			LEV_OPT_REUSEABLE: 设置端口复用
  void evconnlistener_free(struct evconnlistener *lev); 
  ```

  

- 启用和禁用 evconnlistener

  ```c
  #include <event2/listener.h> 
  // 设置无效之后, 就不监听连接请求了
  int evconnlistener_disable(struct evconnlistener *lev);
  int evconnlistener_enable(struct evconnlistener *lev); 
  ```

  

- 调整 evconnlistener 的回调函数

  ```c
   #include <event2/listener.h> 
  void evconnlistener_set_cb(struct evconnlistener *lev, evconnlistener_cb cb, void *arg); 
  ```

  