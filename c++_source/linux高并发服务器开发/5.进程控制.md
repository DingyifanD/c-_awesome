# **1**. 进程概述

## 1.1 程序和进程

- 程序

  就是一个文件, 只占用磁盘的空间

- 进程

  进程不占用磁盘空间, 系统会分配 cpu, 内存

  > 进程，是并发执行的程序在执行过程中分配和管理资源的基本单位，是一个动态概念，竟争计算机系统资源的基本单位。每一个进程都有一个自己的地址空 间，即进程空间或（虚空间）。进程空间的大小 只与处理机的位数有关，一个 16 位长处理机的进程空间大小为 2^16^ ，而 32 位处理机的进程空间大小为 2^32^ 。

## 1.2 并行和并发

- 并行和并发

  ![](assets/Concurrency-vs-Parallelism.png)

  - 并行:  多个人在某一个时间点同时干一件事儿
  - 并发: 描述的是在一个非常短的时间段内处理若干个工作

- CPU时间片

  > 时间片即<font color="red">CPU分配给各个程序的时间，每个进程被分配一个时间段</font>，称作它的时间片，即该进程允许运行的时间，使各个程序从表面上看是同时进行的。<font color="red">如果在时间片结束时进程还在运行，则CPU将被剥夺并分配给另一个进程。如果进程在时间片结束前阻塞或结束，则CPU当即进行切换。</font>而不会造成CPU资源浪费。
  >
  > - 在宏观上：我们可以同时打开多个应用程序，每个程序并行不悖，同时运行。
  >
  > - 但在微观上：由于只有一个CPU，一次只能处理程序要求的一部分，为了公平处理，方法就是引入时间片，让每个程序轮流执行。
  >
  > 在Linux的内核处理过程中，每一个进程默认会有一个固定的时间片来执行命令（<font color="red">默认为1/100秒</font>），这段时间内进程被分配到CPU，然后独占使用。如果使用完，同时未到时间片的规定时间，那么就主动放弃CPU的占用，如果到时间片尚未完成工作，那么CPU的使用权也会被收回，进程将会被中断挂起等待下一个时间片。

## 1.3 PCB

> **PCB - 进程控制块（Processing Control Block）**，Linux内核的进程控制块是task_struct结构体。	
>
> 理解该结构体中包含的如下信息：
>
> - 进程id。系统中每个进程有唯一的id，在C语言中用pid_t类型表示，其实就是一个非负整数。
>
> - 进程的状态，有就绪、运行、挂起、停止等状态。
>
> - 进程切换时需要保存和恢复的一些CPU寄存器。
>
> - 描述虚拟地址空间的信息。
>
> - 描述控制终端的信息。
>
> - 当前工作目录（Current Working Directory）。
>
> - umask掩码。
>
> - 文件描述符表，包含很多指向file结构体的指针。
>
> - 和信号相关的信息。
>
> - 用户id和组id。
>
> - 会话（Session）和进程组。
>
> - 进程可以使用的资源上限（Resource Limit）。

## 1.4 进程状态

> 进程有五种状态, 分别是: 创建态, 就绪态, 运行态, 阻塞态, 退出态。
>
> - 创建态  == 初始态
> - 阻塞态  == 挂起态

## ![1557237111672](assets/1557237111672.png)

```shell
创建态: 初始化系统资源
就绪态: 不能运行, 因为没有cpu资源, 和别的进程抢cpu
运行态: 进程抢到了cpu, 将cpu时间使用完之后, 会再次失去cpu -> 就绪态
阻塞态: 运行的进程(有cpu资源), 受到了某些条件的干扰, 失去了cpu -> sleep(10), 睡醒了之后 -> 就绪态
```



# 2. 进程创建

## 2.1 进程ID

### 2.1.1 命令

- 查看进程

  ```shell
  ps aux / ajx
  	a: 显示当前终端下的所有的程序, 包括所有的用户
  	u: 显示用户信息
  	x: 打印和tty终端先关的信息
  	j: 显示更多的用户信息
  ```

- 杀死进程

  ```shell
  $ kill -l
   1) SIGHUP       2) SIGINT       3) SIGQUIT      4) SIGILL       5) SIGTRAP
   6) SIGABRT      7) SIGBUS       8) SIGFPE       9) SIGKILL     10) SIGUSR1
  11) SIGSEGV     12) SIGUSR2     13) SIGPIPE     14) SIGALRM     15) SIGTERM
  16) SIGSTKFLT   17) SIGCHLD     18) SIGCONT     19) SIGSTOP     20) SIGTSTP
  21) SIGTTIN     22) SIGTTOU     23) SIGURG      24) SIGXCPU     25) SIGXFSZ
  26) SIGVTALRM   27) SIGPROF     28) SIGWINCH    29) SIGIO       30) SIGPWR
  31) SIGSYS      34) SIGRTMIN    35) SIGRTMIN+1  36) SIGRTMIN+2  37) SIGRTMIN+3
  38) SIGRTMIN+4  39) SIGRTMIN+5  40) SIGRTMIN+6  41) SIGRTMIN+7  42) SIGRTMIN+8
  43) SIGRTMIN+9  44) SIGRTMIN+10 45) SIGRTMIN+11 46) SIGRTMIN+12 47) SIGRTMIN+13
  48) SIGRTMIN+14 49) SIGRTMIN+15 50) SIGRTMAX-14 51) SIGRTMAX-13 52) SIGRTMAX-12
  53) SIGRTMAX-11 54) SIGRTMAX-10 55) SIGRTMAX-9  56) SIGRTMAX-8  57) SIGRTMAX-7
  58) SIGRTMAX-6  59) SIGRTMAX-5  60) SIGRTMAX-4  61) SIGRTMAX-3  62) SIGRTMAX-2
  63) SIGRTMAX-1  64) SIGRTMAX
  
  # 杀死进程
  kill -SIGKILL 进程ID
  kill -9 进程ID
  ```

### 2.1.2 函数

- 获取当前进程的进程ID

- 获取当前进程父进程的进程ID

  ```c
  #include <sys/types.h>
  #include <unistd.h>
  
  pid_t getpid(void);	// 当前进程
  pid_t getppid(void); // 当前进程的父进程
  ```

## 2.2 进程的创建

- 如何在程序中创建进程?

  ```c
  // 函数
  #include <unistd.h>
  // 在当前进程中创建一个子进程
  pid_t fork(void);
  返回值: 得到两个数
  	- >0 : 代表是父进程的返回值
  	- == 0: 子进程的返回值
  ```

- 子进程创建成功之后，代码从什么位置执行?

  ![1557289632944](assets/1557289632944.png)

- 父子进程执行的顺序?

- 如何区分父子进程?

  ```shell\
  通过fork的返回值, fork调用成功之后, 会得到两个进程
  每个进程都会返回一个值
  	- 父进程: > 0
  	- 子进程: == 0
  父子进程:
  	- 父进程: 1个 -> 干一件事儿
  	- 子进程: 若干 -> 干同一件事儿
  ```

## 2.3 父子进程

- 区别
  - fork的返回值不同
    - 父进程: >0
    - 子进程: == 0
  - pcb中一些数据
    - 当前进程的PID
    - 当前进程的PPID
    - 信号集
- 共同点
  - 某个状态下: 子进程刚被创建出来, 还没有执行任何操作
    - 用户区数据
    - 文件描述符表
- 父子进程对变量是不是共享的?
  - 刚开始时候一样, 如果数据被修改之后, 不共享
  - 读时共享(子进程被创建, 两个进程没有做任何写操作), 写时复制

# 3. 多进程的gdb调试

- 默认gdb跟踪的是父进程

- 切换命令

  ```shell
  # 设置跟踪子进程
  set follow-fork-mode child
  # 设置跟踪父进程
  set follow-fork-mode parent
  ```

  

# 4. exec族函数

> exec函数族的作用是根据指定的文件名找到[可执行文件](https://baike.baidu.com/item/可执行文件)，并用它来取代调用进程的内容，换句话说，就是在调用进程内部执行一个可执行文件。
>
> exec函数族的函数执行成功后不会返回，因为调用进程的实体，包括[代码段](https://baike.baidu.com/item/代码段)，[数据段](https://baike.baidu.com/item/数据段)和[堆栈](https://baike.baidu.com/item/堆栈)等都已经被新的内容取代，只留下进程ID等一些表面上的信息仍保持原样，颇有些神似"三十六计"中的"金蝉脱壳"。看上去还是旧的躯壳，却已经注入了新的灵魂。只有调用失败了，它们才会返回一个-1，从原程序的调用点接着往下执行。

```c
#include <unistd.h>
extern char **environ;
// 不是linux系统函数
int execl(const char *path, const char *arg, ...);  // 使用最多的
	参数: 
		- path: 可执行程序的路径, 建议写绝对路径
		- arg: 第二个参数, 随便写, 一般为了看起来舒服, 写成和参数1相同的值
		- 从第三个参数: 可执行程序执行过程中需要的真正的参数
		- 最后一个参数: NULL(哨兵)
   举例: /home/itcast/test/a.out
   execl("/home/itcast/test/a.out", "a.out", "hello", "123", NULL);
   execl("/bin/ps", "ps", "a", "u", "x", NULL);

int execlp(const char *file, const char *arg, ...); // 使用最多的
	参数:
		- file: 可执行程序的名字, 在执行这个程序之前, 子动搜索系统环境变量PATH
		- arg: 第二个参数, 随便写, 一般为了看起来舒服, 写成和参数1相同的值
		- 从第三个参数: 可执行程序执行过程中需要的真正的参数
		- 最后一个参数: NULL(哨兵)
int execle(const char *path, const char *arg, ..., char *const envp[]);
	- path: 文件名
	- char *const envp[], 从这个参数指定的路径中所属第一个参数对应的文件名
	char* envp[] = {"/home/robin", "/a/b", "home/zhangsan/test", NULL};

int execv(const char *path, char *const argv[]);
	- path: 例如: /bin/ps
	- argv: 参数列表
	
	char* args[] = {"xxx", "aux", NULL};
int execvp(const char *file, char *const argv[]);
// linux系统函数
int execve(const char *path, char *const argv[], char *const envp[]);	
```

|                |                                          |
| -------------- | ---------------------------------------- |
| l(list)        | 参数地址列表，以空指针结尾               |
| v(vector)      | 存有各参数地址的指针数组的地址           |
| p(path)        | 按 PATH 环境变量指定的目录搜索可执行文件 |
| e(environment) | 存有环境变量字符串地址的指针数组的地址   |

# 5. 进程控制

> 每个进程结束之后, 都会自己释放自己地址空间中的 用户区数据, 内核区的pcb没有办法自己释放掉, 需要父进程去释放.

## 5.1 结束进程

```c
// exit -> c库函数
#include <stdlib.h>
void exit(int status);
exit(-1)

// _exit() -> linux系统函数
#include <unistd.h>
void _exit(int status);
```

## 5.2 孤儿进程

> 爹生孩子, 爹英年早逝, 只剩下孩子, 这个进程就是孤儿进程. 
>
> 孤儿会被领养, 被pid=1的进程, pid=1的进程, 变成了孤儿进程父亲

## 5.3 僵尸进程

> 爹生孩子,  爹还活着, 但是孩子死了, 这时候子进程的pcb需要回收, 这个爹不负责任, 不回收子进程的pcb, 这个进程变成了僵尸进程.
>
> - 僵尸进程: 没有用户区数据, 只有一个pcb, 不能称之为一个存活的进程
> - 僵尸进程不能被 kill -9 杀死

## 5.3 进程回收

```c
#include <sys/types.h>
#include <sys/wait.h>
// 是一个阻塞函数
// 当前当前父进程还有子进程的时候, 调用wait会默认阻塞
// 当前进程的子进程全部被回收之后, 没有子进程了, 继续调用该函数, 不阻塞了
// wait调用一次只能回收一个子进程
pid_t wait(int *status);
	- 参数: status记录了子进程退出时候的状态, 正常->退出值(exit(10))/非正常退出 -> 被信号干掉了
	- 返回值: 
		>0: 被回收的子进程的进程ID
		==-1: 调用失败
		// status参数的使用
			int s;
            int ret = wait(&s);
            if(WIFEXITED(s))	// 判断子进程是不是正常退出
            {   
                printf("退出的状态码: %d\n", WEXITSTATUS(s));	// 打印子进程退出的状态码
            }   
            if(WIFSIGNALED(s))	// 判断子进程是不是被信号干掉了
            {   
                printf("被这个信号干掉了: %d\n", WTERMSIG(s));	// 打印子进程是被那个信号杀死的
            }   	
pid_t waitpid(pid_t pid, int *status, int options);
```



# 6. dup，dup2，fcntl函数

## 6.1 dup和dup2

```c
#include <unistd.h>
// 复制文件描述符
// 值==3的文件描述符指向一个文件a.txt
// int ret = dup(3); // 返回值是从空闲的文件描述符表中找到的最小的一个, 这时候 4 指向a.txt
int dup(int oldfd);
// 重定向文件描述符
// oldfd指向 a.txt, newfd 指向 b.txt
// 函数调用成功之后: newfd和b.txt做close, newfd指向了a.txt
// oldfd必须是一个有效的文件描述符
// oldfd和newfd是相同的值, 等于什么也没做
int dup2(int oldfd, int newfd);
```

```c
// dup.c
#include <stdio.h>
#include <fcntl.h>
#include <unistd.h>
#include <string.h>

int main()
{
    // 打开一个文件
    int fd = open("1.txt", O_RDWR|O_CREAT, 0664);
    if(fd == -1)
    {
        perror("open");
        return -1;
    }
    // 复制文件描述符
    int fd1 = dup(fd);
    close(fd);
    // 写文件
    char* p = "hello, Linux";
    write(fd1, p, strlen(p));
    close(fd1);

    return 0;
}
```



## 6.2 fcntl函数

```c
#include <unistd.h>
#include <fcntl.h>
int fcntl(int fd, int cmd, ... /* arg */ );

// 使用fcntl复制文件描述符 == dup
int ret = fcntl(fd, F_DUPFD);
 - 参数: F_DUPFD, 复制文件描述符, 复制的是第一个参数: fd, 会得到一个新的文件描述符: 返回值ret
 - 参数: F_GETFL -> 获取文件的flags属性
 - 参数: F_SETFL -> 设置文件的flags属性
 
// 设置/获取文件的状态标志 -> flags
int open(const char *pathname, int flags);
int open(const char *pathname, int flags, mode_t mode);
 - 必选项: O_RDONLY,  O_WRONLY,  or  O_RDWR, 这些属性无法修改
 	- 在open的时候设置了 O_RDONLY, 不能通过fcntl 设置 -> O_RDWR
 - 可以通过fcntl修改flags中的可选项
 	- O_APPEND , 数据追加 
 		O_WRONLY | O_APPEND
 	- O_NONBLOCK, 设置非阻塞
 
// 修改文件flags属性测试代码 
#include <fcntl.h>
#include <unistd.h>
#include <string.h>

int main()
{
    // 打开一个文件
    int fd = open("1.txt", O_WRONLY);
    if(fd == -1)
    {
        perror("open");
        return -1;
    }
#if 1
    // 追对文件的操作属性
    // 先得到原来设置的属性
    int flag = fcntl(fd, F_GETFL); 
    // 属性添加
    flag |= O_APPEND;
    // flag = flag | O_APPEND;
    // 设置属性到文件描述符中
    fcntl(fd, F_SETFL, flag);
#endif
    // 写文件
    char* p = "你好, 世界....";
    write(fd, p, strlen(p));
    close(fd);

    return 0;
}
```

- 阻塞和非阻塞

  ```shell
  # 一般描述函数行为
  # 阻塞函数
  有一个函数 sortNum() , 对1000数进行排序, 排序完成函数返回
  函数体的行为执行完成之后, 函数才返回, 得到一个正确的结构
  
  # 非阻塞函数
  函数调用之后, 马上返回, 但是函数体没有执行完成
  ```

  