# 1. UDP

## 1.1 UDP通信

> udp通信不需要建立连接
>
> UDP: 面向无连接的, 不安全(会丢失数据)的, 报文传输

![](assets/udp.jpg)

- UDP通信流程

  ```c
  /*
  	服务器端
        - 创建通信的套接字
          	int fd = socket( af_inet, SOCK_DGRAM, 0);
        - 绑定 -> 通信的fd 和本地 IP / port 绑定
          	struct sockaddr_in seraddr;
          	bind(fd, seraddr, len);
        - 通信
          	接收数据: recvfrom
          	发送数据: sendto
        - 关闭通信的fd
          	close(fd);
  */
  
  /*
  	客户端
    	  - 创建一个通信的套接字
    	  		int fd = socket( af_inet, SOCK_DGRAM, 0);
    	  - 通信
      		接收数据: recvfrom
      		发送数据: sendto
    	  - 关闭通信的文件描述符
      		close();
  */
  ```

- 操作函数

  ```c
  #include <sys/types.h>
  #include <sys/socket.h>
  // udp 发送数据
  ssize_t sendto(int sockfd, const void *buf, size_t len, int flags,
                        const struct sockaddr *dest_addr, socklen_t addrlen);
  	参数:
  		- sockfd: 通信的fd
  	- buf: 要发送的数据
  		- len: 要发送的数据的长度
  		- flags: 0
          - dest_addr: 通信的另外一端的地址信息
          - addrlen: dest_addr的内存大小
  // udp 接收数据函数
  ssize_t recvfrom(int sockfd, void *buf, size_t len, int flags,
                          struct sockaddr *src_addr, socklen_t *addrlen);
  	参数:
  		- sockfd: 通信的fd
  		- buf: 接收数据的一块内存
  		- len: 接收数据的内存(第二个参数)大小
  		- flags: 0
          - src_addr: 接收谁的数据, 就写入了那个终端的地址信息, 如果不要这部分数据 -> NULL
          - addrlen: src_addr参数对应内存大小(传入传出参数)
  ```

## 1.2 广播

> 向子网中多台计算机发送消息，并且子网中所有的计算机都可以接收到发送方发送的消息，每个广播消息都包含一个特殊的IP地址，这个IP中子网内主机标志部分的二进制全部为1。
>
> - 只能在局域网中使用
> - 客户端只要绑定了服务器广播使用的端口, 就可以接收到广播数据

​	![1558602601857](assets/1558602601857.png)

- 通信流程

  ```c
  /*
  	服务器端 -> 广播的一端: 
        - 创建通信的套接字
          	int fd = socket( af_inet, SOCK_DGRAM, 0);
    	  - 设置udp广播属性
    	  		setsockopt();
        - 通信 -> 发送广播数据
        		struct sockaddr_in cliaddr;
        		cliaddr.sin_port(8888);	// 广播数据发送到客户端的8888端口, 客户端需要绑定该端口
        		cliaddr.sin_addr.s_addr -> 初始化一个广播地址
          	发送数据: sendto(fd, buf, len, 0, &cliaddr, len);
        - 关闭通信的fd
          	close(fd);
  */
  
  /*
  	客户端
    	  - 创建一个通信的套接字
    	  		int fd = socket( af_inet, SOCK_DGRAM, 0);
    	  - 如果想接收广播数据, 需要绑定以固定端口(服务器广播数据使用的端口)
    	  		struct sockaddr_in cliaddr;
        		cliaddr.sin_port(8888);	
    	  		bind(fd, cliaddr, len);
    	  - 通信
      		接收数据: recvfrom
    	  - 关闭通信的文件描述符
      		close();
  */
  ```

- 设置广播属性的函数

  ```c
  int setsockopt(int sockfd, int level, int optname,const void *optval, socklen_t optlen);
  	参数:
  		- sockfd: 文件描述符
  		- level: SOL_SOCKET
  		- optname: SO_BROADCAST
  		- optval: int数值为1, 允许广播
  		- optlen: optval内存大小
  ```

## 1.3 组播

> Server给局域网的交换机发送数据，无论连接到局域网的客户端想不想接收该数据，Server都会给客户端发送该数据。—>进而造成客户端上数据的拥塞—>因此引出了多播(组播)：Server可以将数据包只发送给指定组内的客户端，而不发送给指定组外的客户端。
>
> - 可以在internet中进行组播
> - 加入到广播的组织中才可以收到数据

​	![1558602627015](assets/1558602627015.png)

- 组播地址

  > IP 多播通信必须依赖于 IP 多播地址，在 IPv4 中它的范围从  `224.0.0.0` 到 `239.255.255.255`，并被划分为局部链接多播地址、预留多播地址和管理权限多播地址三类:

  |          IP地址           |                             说明                             |
  | :-----------------------: | :----------------------------------------------------------: |
  |   224.0.0.0~224.0.0.255   | 局部链接多播地址：是为路由协议和其它用途保留的地址，路由器并不转发属于此范围的IP包 |
  |   224.0.1.0~224.0.1.255   |  预留多播地址：公用组播地址，可用于Internet；使用前需要申请  |
  | 224.0.2.0~238.255.255.255 |  预留多播地址：用户可用组播地址(临时组地址)，全网范围内有效  |
  | 239.0.0.0~239.255.255.255 | 本地管理组播地址，可供组织内部使用，类似于私有 IP 地址，不能用于 Internet，可限制多播范围 |

- 通信流程

  ```c
  /*
  	服务器端 -> 组播的一端: 
        - 创建通信的套接字
          	int fd = socket( af_inet, SOCK_DGRAM, 0);
    	  - 设置udp组播属性
    	  		setsockopt();
        - 通信 -> 发送组播数据
        		struct sockaddr_in cliaddr;
        		cliaddr.sin_port(8888);	// 广播数据发送到客户端的8888端口, 客户端需要绑定该端口
        		cliaddr.sin_addr.s_addr -> 初始化一个组播地址
          	发送数据: sendto(fd, buf, len, 0, &cliaddr, len);
        - 关闭通信的fd
          	close(fd);
  */
  
  /*
  	客户端
    	  - 创建一个通信的套接字
    	  		int fd = socket( af_inet, SOCK_DGRAM, 0);
    	  - 如果想接收组播数据, 需要绑定以固定端口(服务器组播数据使用的端口)
    	  		struct sockaddr_in cliaddr;
        		cliaddr.sin_port(8888);	
    	  		bind(fd, cliaddr, len);
    	  - 客户端加入到组播网络中
    	  		setsockopt():
    	  - 通信
      		接收数据: recvfrom
    	  - 关闭通信的文件描述符
      		close();
  */
  ```

  

- 设置组播

  ```c
  int setsockopt(int sockfd, int level, int optname,const void *optval, socklen_t optlen);
  
  // 服务器端 -> 进程组播
  	参数: 
  		- sockfd: 通信的文件描述符
  		- level: IPPROTO_IP
  		- optname: IP_MULTICAST_IF
  		- optval: struct in_addr
          - optlen: optval 的内存大小
  // 客户端 -> 加入到多播组
  	参数:
  		- sockfd: 通信的文件描述符
  		- level: IPPROTO_IP
  		- optname: IP_ADD_MEMBERSHIP
  		- optval: struct ip_mreqn
          - optlen: optval 的内存大小
          
  struct ip_mreqn
  {
  	// 组播组的IP地址.
  	struct in_addr imr_multiaddr; 
  	// 本地某一网络设备接口的IP地址。
  	struct in_addr imr_address;   
  	int   imr_ifindex;   // 网卡编号
  };
  ```

  

# 2. 本地套接字

> 进程间通信
>
> - 有血缘关系
> - 没有血缘关系
>
> 通信流程 -> 一般按照tcp流程处理

![](assets/sockaddr.png)

- 结构体

  ```c
  // 头文件:  sys/un.h
  #define UNIX_PATH_MAX 108
  struct sockaddr_un {
  	sa_family_t sun_family; // 地址族协议 af_local
  	char sun_path[UNIX_PATH_MAX];	// 套接字文件的路径, 这是一个伪文件, 大小永远=0
  };
  ```

- 通信流程

  ```c
  // 服务器端 -> tcp
  1. 创建监听的套接字
  	int lfd = socket(af_local, sock_stream, 0);
  		第一个参数: AF_UNIX, AF_LOCAL
  2. 监听的套接字绑定本地的 套接字文件-> server端
  	struct sockaddr_un addr;
  	// 绑定成功之后, 指定的sun_path中的套接字文件会自动生成
  	bind(lfd, addr, len);
  3. 监听
  	listen(lfd, 100);
  4. 等待并接受连接请求
  	struct sockaddr_un cliaddr;
  	int connfd  = accept(lfd, cliaddr, len);
  5. 通信
  	接收数据: read/recv
  	发送数据: write/send
  6. 关闭连接
  	close();
  
  
  // 客户端
  1. 创建通信的套接字
  	int fd = socket(af_local, sock_stream, 0);
  2. 监听的套接字绑定本地的IP 端口
  	struct sockaddr_un addr;
  	// 绑定成功之后, 指定的sun_path中的套接字文件会自动生成
  	bind(fd, addr, len);
  3. 连接服务器
  	struct sockaddr_un serveraddr;
  	connect(fd, serveraddr, sizeof(serveraddr));
  4. 通信
  	接收数据: read/recv
  	发送数据: write/send
  5. 关闭连接
  	close();
  ```

  